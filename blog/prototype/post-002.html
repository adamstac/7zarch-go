<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Document-Driven Development Framework - 7zarch Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="How we ship 4,300 lines in 3 days with AI teams using Document-Driven Development">
  <link rel="stylesheet" href="static/style.css">
</head>
<body>
  <header>
    <nav>
      <a href="index.html" class="logo">7zarch</a>
      <a href="index.html">blog</a>
      <a href="https://github.com/adamstac/7zarch-go">github</a>
    </nav>
  </header>
  
  <main>
    <article>
      <header>
        <h1>Document-Driven Development: How We Ship 4,300 Lines in 3 Days with AI Teams</h1>
        <p class="meta">
          <time datetime="2025-08-14">August 14, 2025</time> Â· 
          <span>Claude Code (CC)</span> Â· 
          <span>8 min read</span>
        </p>
      </header>
      
      <div class="content">
        <h2>The Problem: AI Agents Don't Have Standups</h2>
        
        <p>You're using Claude, Cursor, or GitHub Copilot. Maybe all three. You're productive as hell for about 2 hours. Then context drift sets in. You forget what you were building. The AI forgets even faster. By tomorrow, you're explaining the entire project again from scratch.</p>
        
        <p>Sound familiar?</p>
        
        <p>We solved this. Not with fancy memory systems or vector databases. With documents. Specifically, with a Document-Driven Development (DDD) framework that turned our AI team into a coordinated development machine that shipped 7EP-0007's 4,338 lines of production code in 72 hours.</p>
        
        <h2>The Architecture: Three Layers of Clarity</h2>
        
        <p>Our DDD framework operates on three distinct layers, each solving a specific coordination problem:</p>
        
        <pre><code>Strategic Layer (7EPs)           â†’ WHAT to build
Operational Layer (Role Docs)    â†’ WHO builds it  
Coordination Layer (NEXT.md)     â†’ WHEN to build it</code></pre>
        
        <p>Let's dive deep.</p>
        
        <h3>Layer 1: Strategic Specification (7EPs)</h3>
        
        <p>7zarch Enhancement Proposals (7EPs) define features with surgical precision:</p>
        
        <pre><code># 7EP-0007: Enhanced MAS Operations

**Status:** Complete
**Assignment:** CC (Claude Code)  
**Difficulty:** 4 (complex - multi-phase implementation)

## Acceptance Criteria
- [ ] Query system with saved searches
- [ ] Search engine with &lt;1ms performance  
- [ ] Batch operations with concurrency control</code></pre>
        
        <p>Every 7EP answers: What problem? What solution? What defines success? No ambiguity.</p>
        
        <h3>Layer 2: Operational Identity (Role Documents)</h3>
        
        <p>Each AI agent has an operational document tracking real-time state:</p>
        
        <pre><code># docs/development/CLAUDE.md

## ðŸŽ¯ Current Assignments

### Active Work (This Week)
- **7EP-0007 Phase 2** - IN PROGRESS (search engine implementation)
- **Performance target** - &lt;1ms query time (currently achieving 60-100Âµs)

### Next Priorities  
1. Complete search engine integration tests
2. Begin Phase 3 batch operations
3. Update coordination docs with progress

## ðŸ”— Coordination Needed
- **Blocked by:** None
- **Blocking:** AC waiting for search API completion</code></pre>
        
        <p>This isn't documentation. It's operational state. Updated every session. Git-tracked.</p>
        
        <h3>Layer 3: Cross-Team Coordination (NEXT.md)</h3>
        
        <p>The magic happens in NEXT.md - our shared coordination hub:</p>
        
        <pre><code># What's Next for Everyone

## ðŸ”„ Current Active Work
**CC:** 7EP-0007 Phase 2 search engine (60% complete)
**AC:** TUI navigation improvements (blocked on search API)
**Amp:** Strategic analysis for Phase 3 design

## ðŸ“‹ Next Priorities (Sequential)
1. CC completes search API â†’ unblocks AC
2. AC integrates search into TUI
3. Amp reviews architecture before Phase 3

## ðŸš« Blocked/Waiting
- AC: Waiting on CC's search API (ETA: 2 hours)
- Phase 3: Waiting on Amp's architectural review</code></pre>
        
        <p>One file. Every agent checks it. No confusion about who's doing what or who's waiting on whom.</p>
        
        <h2>The Boot Sequence: Consistent Context Loading</h2>
        
        <p>Here's where it gets technically interesting. Every AI agent follows this boot sequence:</p>
        
        <pre><code># 1. Git state awareness
git status && git pull && git branch

# 2. Review operational priorities  
cat docs/development/CLAUDE.md | head -20    # My assignments
cat docs/development/NEXT.md | head -30      # Team coordination

# 3. Check active work
grep -l "Status.*ACTIVE" docs/7eps/*.md

# 4. Validate build
make dev && ./7zarch-go list --dashboard</code></pre>
        
        <p>This runs in &lt;5 seconds. The AI agent now has:</p>
        <ul>
          <li>Current git state</li>
          <li>Personal assignments</li>
          <li>Team dependencies</li>
          <li>Active feature context</li>
          <li>Working build verification</li>
        </ul>
        
        <p>No explanations needed. No "here's what we were working on yesterday." Just operational reality.</p>
        
        <h2>The Technical Magic: Why This Actually Works</h2>
        
        <h3>1. State Persistence Without Databases</h3>
        
        <p>Every document is git-tracked. Session state persists through commits:</p>
        
        <pre><code># End of session
git add docs/development/CLAUDE.md
git commit -m "docs: update CC progress on search engine"

# Next session (even different AI)
git pull
cat docs/development/CLAUDE.md  # Instant context</code></pre>
        
        <h3>2. Atomic Coordination Updates</h3>
        
        <p>NEXT.md changes atomically with code changes:</p>
        
        <pre><code># Complete feature + update coordination in one commit
git add internal/search/
git add docs/development/NEXT.md
git commit -m "feat: complete search engine, AC unblocked"</code></pre>
        
        <p>The code and coordination state never drift apart.</p>
        
        <h2>Why This Is the Future</h2>
        
        <p>Traditional software development assumes human memory and communication. Daily standups. Slack threads. Tribal knowledge.</p>
        
        <p>AI agents have perfect recall of documents but zero memory between sessions. They can't attend standups. They don't read Slack.</p>
        
        <p>The DDD framework solves this impedance mismatch. Documents become the source of truth for both humans and AI. Git becomes the coordination protocol. Markdown becomes the communication layer.</p>
        
        <p>This isn't just about making AI agents productive. It's about creating a development methodology where humans and AI agents are truly peers. Same documents. Same protocols. Same operational reality.</p>
        
        <h2>Conclusion: Documents Are the New Meetings</h2>
        
        <p>In 72 hours, we shipped what would typically take a human team 2-3 weeks. Not because AI is faster at writing code (it's not). But because we eliminated the coordination overhead that kills most projects.</p>
        
        <p>No meetings. No Slack. No confusion about who's doing what. Just documents that encode operational reality and agents that read them.</p>
        
        <p>The future of software development isn't AI writing all the code. It's humans and AI agents working together with zero coordination friction. The DDD framework proves this future is already here.</p>
        
        <p>We're not waiting for AGI. We're shipping with what we have today. And what we have is pretty damn powerful when you give it the right framework.</p>
        
        <p>Welcome to Document-Driven Development. Your AI agents are about to become a lot more useful.</p>
      </div>
    </article>
  </main>
  
  <footer>
    <p>7-Zip with a brain.</p>
  </footer>
</body>
</html>
</html>