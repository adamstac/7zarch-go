
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/adamstac/7zarch-go/cmd/config.go (0.0%)</option>
				
				<option value="file1">github.com/adamstac/7zarch-go/cmd/create.go (0.0%)</option>
				
				<option value="file2">github.com/adamstac/7zarch-go/cmd/list.go (7.9%)</option>
				
				<option value="file3">github.com/adamstac/7zarch-go/cmd/mas_db.go (0.0%)</option>
				
				<option value="file4">github.com/adamstac/7zarch-go/cmd/mas_delete.go (10.0%)</option>
				
				<option value="file5">github.com/adamstac/7zarch-go/cmd/mas_move.go (0.0%)</option>
				
				<option value="file6">github.com/adamstac/7zarch-go/cmd/mas_show.go (0.0%)</option>
				
				<option value="file7">github.com/adamstac/7zarch-go/cmd/profiles.go (0.0%)</option>
				
				<option value="file8">github.com/adamstac/7zarch-go/cmd/restore.go (80.5%)</option>
				
				<option value="file9">github.com/adamstac/7zarch-go/cmd/test.go (0.0%)</option>
				
				<option value="file10">github.com/adamstac/7zarch-go/cmd/trash.go (82.8%)</option>
				
				<option value="file11">github.com/adamstac/7zarch-go/cmd/upload.go (0.0%)</option>
				
				<option value="file12">github.com/adamstac/7zarch-go/internal/archive/archive.go (3.0%)</option>
				
				<option value="file13">github.com/adamstac/7zarch-go/internal/archive/profiles.go (22.0%)</option>
				
				<option value="file14">github.com/adamstac/7zarch-go/internal/cmdutil/helpers.go (0.0%)</option>
				
				<option value="file15">github.com/adamstac/7zarch-go/internal/config/config.go (0.0%)</option>
				
				<option value="file16">github.com/adamstac/7zarch-go/internal/debug/metrics.go (0.0%)</option>
				
				<option value="file17">github.com/adamstac/7zarch-go/internal/display/display.go (0.0%)</option>
				
				<option value="file18">github.com/adamstac/7zarch-go/internal/display/modes/card.go (0.0%)</option>
				
				<option value="file19">github.com/adamstac/7zarch-go/internal/display/modes/compact.go (0.0%)</option>
				
				<option value="file20">github.com/adamstac/7zarch-go/internal/display/modes/dashboard.go (0.0%)</option>
				
				<option value="file21">github.com/adamstac/7zarch-go/internal/display/modes/table.go (0.0%)</option>
				
				<option value="file22">github.com/adamstac/7zarch-go/internal/display/modes/tree.go (0.0%)</option>
				
				<option value="file23">github.com/adamstac/7zarch-go/internal/errors/errors.go (0.0%)</option>
				
				<option value="file24">github.com/adamstac/7zarch-go/internal/storage/archive.go (0.0%)</option>
				
				<option value="file25">github.com/adamstac/7zarch-go/internal/storage/errors.go (0.0%)</option>
				
				<option value="file26">github.com/adamstac/7zarch-go/internal/storage/manager.go (58.3%)</option>
				
				<option value="file27">github.com/adamstac/7zarch-go/internal/storage/migrations.go (69.1%)</option>
				
				<option value="file28">github.com/adamstac/7zarch-go/internal/storage/registry.go (75.2%)</option>
				
				<option value="file29">github.com/adamstac/7zarch-go/internal/storage/resolver.go (75.9%)</option>
				
				<option value="file30">github.com/adamstac/7zarch-go/internal/storage/test_helpers.go (0.0%)</option>
				
				<option value="file31">github.com/adamstac/7zarch-go/internal/storage/uid.go (100.0%)</option>
				
				<option value="file32">github.com/adamstac/7zarch-go/main.go (0.0%)</option>
				
				<option value="file33">github.com/adamstac/7zarch-go/test-datasets/generators/generator.go (0.0%)</option>
				
				<option value="file34">github.com/adamstac/7zarch-go/test-datasets/generators/scenarios.go (0.0%)</option>
				
				<option value="file35">github.com/adamstac/7zarch-go/test-datasets/helpers/test_helpers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/adamstac/7zarch-go/internal/config"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

func ConfigCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Manage configuration",
                Long:  `Manage 7zarch-go configuration file and settings.`,
        }

        cmd.AddCommand(configInitCmd())
        cmd.AddCommand(configShowCmd())

        return cmd
}</span>

func configInitCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Create default config file",
                Long:  `Create a default configuration file at ~/.7zarch-go-config with examples and documentation.`,
                RunE:  runConfigInit,
        }

        return cmd
}</span>

func configShowCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "show",
                Short: "Show current configuration",
                Long:  `Display the current configuration including defaults and any custom settings.`,
                RunE:  runConfigShow,
        }

        return cmd
}</span>

func runConfigInit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        configPath, err := config.ConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get config path: %w", err)
        }</span>

        // Check if config already exists
        <span class="cov0" title="0">if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("Config file already exists: %s\n", configPath)
                fmt.Printf("Remove it first if you want to recreate it.\n")
                return nil
        }</span>

        // Create default config with comments
        <span class="cov0" title="0">configContent := `# 7zarch-go Configuration
# Convention over configuration - smart defaults work great!
# Only customize what you need.

# Compression behavior
compression:
  # Smart compression analyzes your content and picks optimal settings
  # Set to false to always use manual compression levels
  smart_default: true
  
  # Default compression level when smart mode is disabled (0-9)
  level: 9
  
  # Override smart recommendations for specific content types
  media_threshold: 70    # % media files needed to trigger media profile
  docs_threshold: 60     # % document files needed to trigger docs profile

# Default flags for commands
defaults:
  create:
    comprehensive: false   # Create .log and .sha256 files by default
    force: false          # Overwrite existing archives by default
    threads: 0            # 0 = auto-detect CPU cores
  
  test:
    concurrent: 5         # Default concurrent archive tests
    verbose: false        # Show detailed test output by default

# Output and display
ui:
  # Show educational content analysis on every create
  show_analysis: true
  
  # Show optimization tips when not using optimal settings
  show_tips: true
  
  # Progress display style: "spinner", "bar", "minimal"
  progress_style: "spinner"
  
  # Use emojis in output (disable for CI/automation)
  emojis: true

# Custom compression profiles (extend built-in ones)
profiles:
  # Example: Ultra-fast profile for development/testing
  fast:
    name: "Fast"
    description: "Minimal compression for development and testing"
    level: 1
    dictionary: "4m"
    fast_bytes: 32
    solid_mode: false
    algorithm: "lzma2"
  
  # Example: Maximum compression profile
  maximum:
    name: "Maximum"
    description: "Slowest but highest compression ratio"
    level: 9
    dictionary: "128m"
    fast_bytes: 273
    solid_mode: true
    algorithm: "lzma2"

# TrueNAS integration (when implemented)
truenas:
  default_host: "truenas-homelab.local"
  upload_path: "/mnt/tank/archives"
  verify_ssl: true
  timeout: 300

# Presets - saved combinations of common flags
presets:
  podcast:
    profile: "media"
    comprehensive: true
    output: "~/Archives"
    exclude: ["__MACOSX", ".DS_Store", "*.pkf"]
  
  backup:
    profile: "balanced"
    comprehensive: true
    force: true
  
  source_code:
    profile: "documents"
    comprehensive: true
    exclude: ["node_modules", ".git", "target", "build"]
`

        // Write config file
        // Use restrictive permissions for config file
        if err := os.WriteFile(configPath, []byte(configContent), 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Created config file: %s\n", configPath)
        fmt.Printf("\nEdit this file to customize your 7zarch-go defaults and presets.\n")
        fmt.Printf("Run '7zarch-go config show' to see your current settings.\n")

        return nil</span>
}

func runConfigShow(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">configPath, _ := config.ConfigPath()
        fmt.Printf("Configuration loaded from: %s\n\n", configPath)

        // Convert to YAML and display
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Current Configuration:\n")
        fmt.Printf("=====================\n")
        fmt.Print(string(data))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/archive"
        "github.com/adamstac/7zarch-go/internal/config"
        errs "github.com/adamstac/7zarch-go/internal/errors"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/schollz/progressbar/v3"
        "github.com/spf13/cobra"
)

var (
        compressionLevel int
        threads          int
        verbose          bool
        dryRun           bool
        outputPath       string
        comprehensive    bool
        createLog        bool
        createChecksums  bool
        forceOverwrite   bool
        profileName      string
        presetName       string
        noManaged        bool
)

func CreateCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "create &lt;path&gt;",
                Short: "Create a new 7z archive with smart compression",
                Long: `Create a new 7z archive from the specified path with intelligent compression.

The create command automatically optimizes compression based on file types:
- Media files: Minimal compression for JPEGs, MP4s, etc.
- Documents: Maximum compression for text, PDFs, Office files
- Mixed content: Balanced approach for best size/speed ratio

Archives are stored in managed storage by default for easy tracking.`,
                Example: `  # Create archive with auto-detected compression
  7zarch-go create ~/Documents/project

  # Use specific compression profile
  7zarch-go create --profile media ~/Photos/vacation
  7zarch-go create --profile documents ~/Documents/reports

  # Comprehensive mode (includes checksums and metadata)
  7zarch-go create --comprehensive ~/important-backup

  # Custom output location
  7zarch-go create -o /backup/archive.7z ~/data

  # Dry run to preview without creating
  7zarch-go create --dry-run ~/test-folder`,
                Args:  cobra.ExactArgs(1),
                RunE:  runCreate,
        }

        // Add flags
        cmd.Flags().IntVarP(&amp;compressionLevel, "compression", "c", 0, "Compression level (0-9, 0=smart default)")
        cmd.Flags().IntVarP(&amp;threads, "threads", "t", 0, "Number of threads (0=auto)")
        cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Verbose output")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be done without doing it")
        cmd.Flags().StringVarP(&amp;outputPath, "output", "o", "", "Output path for archive (default: managed storage)")
        cmd.Flags().BoolVar(&amp;comprehensive, "comprehensive", false, "Create archive with log and checksums")
        cmd.Flags().BoolVar(&amp;createLog, "log", false, "Create metadata log file")
        cmd.Flags().BoolVar(&amp;createChecksums, "checksums", false, "Create SHA256 checksum file")
        cmd.Flags().BoolVarP(&amp;forceOverwrite, "force", "f", false, "Overwrite existing archive")
        cmd.Flags().StringVar(&amp;profileName, "profile", "", "Compression profile (media, documents, balanced)")
        cmd.Flags().StringVar(&amp;presetName, "preset", "", "Use predefined settings preset")
        cmd.Flags().BoolVar(&amp;noManaged, "no-managed", false, "Don't use managed storage (use current directory)")

        return cmd
}</span>

func runCreate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        sourcePath := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Config loading failed, using defaults: %v\n", err)
                cfg = config.DefaultConfig()
        }</span>

        // Apply preset if specified
        <span class="cov0" title="0">if presetName != "" </span><span class="cov0" title="0">{
                preset, exists := cfg.Presets[presetName]
                if !exists </span><span class="cov0" title="0">{
                        availablePresets := make([]string, 0, len(cfg.Presets))
                        for name := range cfg.Presets </span><span class="cov0" title="0">{
                                availablePresets = append(availablePresets, name)
                        }</span>
                        <span class="cov0" title="0">return &amp;errs.ValidationError{
                                Field:   "preset",
                                Value:   presetName,
                                Message: fmt.Sprintf("unknown preset. Available: %s", strings.Join(availablePresets, ", ")),
                        }</span>
                }

                // Apply preset values (CLI flags override presets)
                <span class="cov0" title="0">if profileName == "" &amp;&amp; preset.Profile != "" </span><span class="cov0" title="0">{
                        profileName = preset.Profile
                }</span>
                <span class="cov0" title="0">if !comprehensive &amp;&amp; preset.Comprehensive </span><span class="cov0" title="0">{
                        comprehensive = preset.Comprehensive
                }</span>
                <span class="cov0" title="0">if !forceOverwrite &amp;&amp; preset.Force </span><span class="cov0" title="0">{
                        forceOverwrite = preset.Force
                }</span>
                <span class="cov0" title="0">if outputPath == "" &amp;&amp; preset.Output != "" </span><span class="cov0" title="0">{
                        // Expand tilde in output path
                        if strings.HasPrefix(preset.Output, "~/") </span><span class="cov0" title="0">{
                                home, _ := os.UserHomeDir()
                                outputPath = filepath.Join(home, preset.Output[2:])
                        }</span> else<span class="cov0" title="0"> {
                                outputPath = preset.Output
                        }</span>
                }
                <span class="cov0" title="0">if threads == 0 &amp;&amp; preset.Threads &gt; 0 </span><span class="cov0" title="0">{
                        threads = preset.Threads
                }</span>

                <span class="cov0" title="0">fmt.Printf("📋 Using preset: %s\n", presetName)</span>
        }

        // Apply config defaults (CLI flags and presets override config)
        <span class="cov0" title="0">if !comprehensive &amp;&amp; cfg.Defaults.Create.Comprehensive </span><span class="cov0" title="0">{
                comprehensive = cfg.Defaults.Create.Comprehensive
        }</span>
        <span class="cov0" title="0">if !forceOverwrite &amp;&amp; cfg.Defaults.Create.Force </span><span class="cov0" title="0">{
                forceOverwrite = cfg.Defaults.Create.Force
        }</span>
        <span class="cov0" title="0">if threads == 0 &amp;&amp; cfg.Defaults.Create.Threads &gt; 0 </span><span class="cov0" title="0">{
                threads = cfg.Defaults.Create.Threads
        }</span>

        // Resolve absolute path
        <span class="cov0" title="0">absPath, err := filepath.Abs(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve path: %w", err)
        }</span>

        // Check if source exists
        <span class="cov0" title="0">_, err = os.Stat(absPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;errs.NotFoundError{
                                Resource:    "Path",
                                ID:          absPath,
                                Suggestions: []string{"check the path spelling", "use an absolute path"},
                        }
                }</span>
                <span class="cov0" title="0">return &amp;errs.FileSystemError{
                        Path:      absPath,
                        Operation: "access",
                        Err:       err,
                }</span>
        }

        // Initialize storage manager if using managed storage
        <span class="cov0" title="0">var storageManager *storage.Manager
        var useManaged bool

        // Determine if we should use managed storage
        if outputPath == "" &amp;&amp; !noManaged &amp;&amp; cfg.Storage.UseManagedDefault </span><span class="cov0" title="0">{
                // Use managed storage
                useManaged = true
                storageManager, err = storage.NewManager(cfg.Storage.ManagedPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize managed storage: %w", err)
                }</span>
                <span class="cov0" title="0">defer storageManager.Close()</span>
        }

        // If we are not using managed storage, initialize the registry if configured to register external outputs
        <span class="cov0" title="0">if !useManaged &amp;&amp; cfg.Storage.RegisterExternal </span><span class="cov0" title="0">{
                storageManager, err = storage.NewManager(cfg.Storage.ManagedPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize registry for external output: %w", err)
                }</span>
                <span class="cov0" title="0">defer storageManager.Close()</span>
        }

        // Determine archive name and path
        <span class="cov0" title="0">var archiveName string
        baseName := filepath.Base(absPath) + ".7z"

        if outputPath != "" </span><span class="cov0" title="0">{
                // Explicit output path specified
                if filepath.Ext(outputPath) == ".7z" </span><span class="cov0" title="0">{
                        archiveName = outputPath
                }</span> else<span class="cov0" title="0"> {
                        // If directory specified, add filename
                        archiveName = filepath.Join(outputPath, baseName)
                }</span>
        } else<span class="cov0" title="0"> if useManaged </span><span class="cov0" title="0">{
                // Use managed storage
                archiveName = storageManager.GetManagedPath(baseName)
        }</span> else<span class="cov0" title="0"> {
                // Default to current directory
                archiveName = baseName
        }</span>

        // Enable log and checksums if comprehensive mode (handled in archive.Manager)
        // We keep flags for display only; artifact creation is centralized in internal/archive
        <span class="cov0" title="0">if comprehensive </span><span class="cov0" title="0">{
                createLog = true
                createChecksums = true
        }</span>

        // Check if archive already exists
        <span class="cov0" title="0">if _, err := os.Stat(archiveName); err == nil &amp;&amp; !forceOverwrite </span><span class="cov0" title="0">{
                // File exists and force not specified
                fmt.Printf("❌ Archive already exists: %s\n", archiveName)
                fmt.Printf("\nOptions:\n")
                fmt.Printf("  • Use --force to overwrite\n")
                fmt.Printf("  • Use a different --output path\n")
                fmt.Printf("  • Delete the existing file first\n")
                return fmt.Errorf("archive already exists (use --force to overwrite)")
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("DRY RUN MODE - No files will be created\n\n")
                fmt.Printf("Would create archive: %s\n", archiveName)
                fmt.Printf("Source: %s\n", absPath)
                fmt.Printf("Compression level: %d\n", compressionLevel)
                if threads &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Threads: %d\n", threads)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Threads: auto\n")
                }</span>
                <span class="cov0" title="0">if createLog </span><span class="cov0" title="0">{
                        fmt.Printf("Would create log: %s.log\n", archiveName)
                }</span>
                <span class="cov0" title="0">if createChecksums </span><span class="cov0" title="0">{
                        fmt.Printf("Would create checksum: %s.sha256\n", archiveName)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Show meaningful start message (after profile is determined)
        <span class="cov0" title="0">fmt.Printf("Creating archive: %s\n", filepath.Base(archiveName))
        fmt.Printf("Source: %s\n", absPath)
        // Note: Compression level will be shown after profile determination
        if threads &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Threads: %d\n", threads)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Threads: auto\n")
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n")

        // Create a spinner that shows we're working
        bar := progressbar.NewOptions(-1,
                progressbar.OptionSetDescription("Compressing"),
                progressbar.OptionSetWidth(40),
                progressbar.OptionThrottle(200*time.Millisecond),
                progressbar.OptionSpinnerType(14),
        )

        // Create archive manager
        manager := archive.NewManager()

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
        defer cancel()

        // Start the spinner
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                _ = bar.Add(1) // best-effort UI update
                                time.Sleep(100 * time.Millisecond)</span>
                        }
                }
        }()

        // Handle excludes from preset
        <span class="cov0" title="0">var excludes []string
        if presetName != "" </span><span class="cov0" title="0">{
                if preset, exists := cfg.Presets[presetName]; exists </span><span class="cov0" title="0">{
                        excludes = append(excludes, preset.Exclude...)
                }</span>
        }

        // Create the archive
        <span class="cov0" title="0">opts := archive.CreateOptions{
                Source:           absPath,
                Output:           archiveName,
                CompressionLevel: compressionLevel,
                Threads:          threads,
                Profile:          profileName,
                Comprehensive:    comprehensive,
                Force:            forceOverwrite,
                Exclude:          excludes,
                MediaThreshold:   cfg.Compression.MediaThreshold,
                DocsThreshold:    cfg.Compression.DocsThreshold,
        }

        startTime := time.Now()
        result, err := manager.Create(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive: %w", err)
        }</span>

        <span class="cov0" title="0">_ = bar.Finish() // best-effort UI cleanup
        duration := time.Since(startTime)

        // Artifact creation (log/checksum) is handled inside archive.Manager when --comprehensive is used.
        // If the user explicitly requested only one artifact without --comprehensive, we could support that here.
        // For now, we centralize to avoid duplication.

        // Register in registry (managed or external)
        if storageManager != nil </span><span class="cov0" title="0">{
                managed := useManaged
                if err := storageManager.Add(
                        filepath.Base(result.Path),
                        result.Path,
                        result.Size,
                        result.Profile.Name,
                        result.Checksum,
                        "",
                        managed,
                ); err != nil </span><span class="cov0" title="0">{
                        // Non-fatal error - archive was created successfully
                        fmt.Printf("⚠️  Warning: Failed to register archive in registry: %v\n", err)
                }</span>
        }

        // Print results
        <span class="cov0" title="0">fmt.Printf("\n✅ Archive created successfully!\n")
        if useManaged </span><span class="cov0" title="0">{
                fmt.Printf("📦 Stored in managed storage: %s\n", filepath.Base(result.Path))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Archive: %s\n", result.Path)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Size: %.2f MB\n", float64(result.Size)/(1024*1024))
        fmt.Printf("Files: %d\n", result.FileCount)
        fmt.Printf("Compression: Level %d (%s profile)\n", result.Profile.Level, result.Profile.Name)
        fmt.Printf("Duration: %s\n", duration.Round(time.Second))

        if result.Size &gt; 0 &amp;&amp; result.OriginalSize &gt; 0 </span><span class="cov0" title="0">{
                ratio := float64(result.Size) / float64(result.OriginalSize) * 100
                fmt.Printf("Size reduction: %.1f%%\n", 100-ratio)
        }</span>

        <span class="cov0" title="0">if useManaged </span><span class="cov0" title="0">{
                fmt.Printf("\n💡 Tip: Use '7zarch-go list' to see all managed archives\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/config"
        "github.com/adamstac/7zarch-go/internal/debug"
        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/display/modes"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

// parseHumanDuration supports 'd' (days) and 'w' (weeks) in addition to time.ParseDuration units
// Kept local to this file to avoid changing behavior elsewhere
func parseHumanDuration(s string) (time.Duration, error) <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("empty duration")
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(s, "d") </span><span class="cov8" title="1">{
                n, err := strconv.ParseInt(strings.TrimSuffix(s, "d"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid days: %w", err)
                }</span>
                <span class="cov8" title="1">return time.Duration(n) * 24 * time.Hour, nil</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(s, "w") </span><span class="cov8" title="1">{
                n, err := strconv.ParseInt(strings.TrimSuffix(s, "w"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid weeks: %w", err)
                }</span>
                <span class="cov8" title="1">return time.Duration(n) * 7 * 24 * time.Hour, nil</span>
        }
        <span class="cov8" title="1">return time.ParseDuration(s)</span>
}

// listFilters collects flags for registry listing
type listFilters struct {
        details      bool
        notUploaded  bool
        pattern      string
        olderThan    string
        onlyManaged  bool
        onlyExternal bool
        onlyMissing  bool
        status       string
        profile      string
        largerThan   int64
        debug        bool
}

func ListCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List archives in the registry with various display and filtering options",
                Long: `List all archives tracked in the registry with rich display modes and filtering.

The list command provides multiple ways to view and filter your archives:
- Display modes: table, compact, card, tree, dashboard
- Filters: by size, age, status, profile, location
- Output formats: human-readable or machine-readable (JSON/CSV)

Display mode is auto-detected based on terminal width if not specified.`,
                Example: `  # List all archives with auto-detected display
  7zarch-go list

  # Use specific display modes
  7zarch-go list --table            # High-density table view
  7zarch-go list --dashboard        # Management overview
  7zarch-go list --card             # Detailed cards for each archive

  # Filter archives
  7zarch-go list --missing          # Only missing archives
  7zarch-go list --managed          # Only managed archives
  7zarch-go list --older-than 30d   # Archives older than 30 days
  7zarch-go list --larger-than 100M # Archives larger than 100MB
  
  # Machine-readable output
  7zarch-go list --output json      # JSON format for scripting
  7zarch-go list --output csv       # CSV format for spreadsheets`,
                RunE:  runList,
        }

        // Add flags
        cmd.Flags().String("directory", "", "List archives in specific directory instead of managed storage")
        cmd.Flags().Bool("details", false, "Show detailed information")
        cmd.Flags().Bool("not-uploaded", false, "Show only archives that haven't been uploaded")
        cmd.Flags().String("pattern", "", "Filter archives by name pattern")
        cmd.Flags().String("older-than", "", "Show archives older than duration (e.g., '7d', '1h')")
        cmd.Flags().Bool("managed", false, "Only managed archives")
        cmd.Flags().Bool("external", false, "Only external archives")
        cmd.Flags().Bool("missing", false, "Only missing archives")
        cmd.Flags().String("status", "", "Filter by status (present|missing|deleted)")
        cmd.Flags().String("profile", "", "Filter by profile (media|documents|balanced)")
        cmd.Flags().Int64("larger-than", 0, "Filter by size larger than bytes (e.g., 1048576)")

        // Display mode flags
        cmd.Flags().Bool("table", false, "Use table display mode (enhanced)")
        cmd.Flags().Bool("compact", false, "Use compact display mode")
        cmd.Flags().Bool("card", false, "Use card display mode")
        cmd.Flags().Bool("tree", false, "Use tree display mode")
        cmd.Flags().Bool("dashboard", false, "Use dashboard display mode")
        
        // Debug flag
        cmd.Flags().Bool("debug", false, "Show performance and debug information")

        return cmd
}</span>

func runList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        directory, _ := cmd.Flags().GetString("directory")
        opts := listFilters{
                details:      getBool(cmd, "details"),
                notUploaded:  getBool(cmd, "not-uploaded"),
                pattern:      getString(cmd, "pattern"),
                olderThan:    getString(cmd, "older-than"),
                onlyManaged:  getBool(cmd, "managed"),
                onlyExternal: getBool(cmd, "external"),
                onlyMissing:  getBool(cmd, "missing"),
                status:       getString(cmd, "status"),
                profile:      getString(cmd, "profile"),
                largerThan:   getInt64(cmd, "larger-than"),
                debug:        getBool(cmd, "debug"),
        }
        
        // Initialize metrics if debug mode
        var metrics *debug.Metrics
        if opts.debug </span><span class="cov0" title="0">{
                metrics = debug.NewMetrics()
        }</span>

        // Determine display mode
        <span class="cov0" title="0">displayMode := determineDisplayMode(cmd)

        if directory != "" </span><span class="cov0" title="0">{
                // List archives in a specific directory
                return listDirectory(directory, opts.details, opts.pattern)
        }</span>

        // List registry-tracked archives
        <span class="cov0" title="0">return listRegistryArchivesWithDisplay(opts, displayMode, metrics)</span>
}

// flag helpers
func getBool(cmd *cobra.Command, name string) bool     <span class="cov0" title="0">{ v, _ := cmd.Flags().GetBool(name); return v }</span>
func getString(cmd *cobra.Command, name string) string <span class="cov0" title="0">{ v, _ := cmd.Flags().GetString(name); return v }</span>
func getInt64(cmd *cobra.Command, name string) int64   <span class="cov0" title="0">{ v, _ := cmd.Flags().GetInt64(name); return v }</span>

// determineDisplayMode selects the display mode based on flags
func determineDisplayMode(cmd *cobra.Command) display.Mode <span class="cov0" title="0">{
        if getBool(cmd, "table") </span><span class="cov0" title="0">{
                return display.ModeTable
        }</span>
        <span class="cov0" title="0">if getBool(cmd, "compact") </span><span class="cov0" title="0">{
                return display.ModeCompact
        }</span>
        <span class="cov0" title="0">if getBool(cmd, "card") </span><span class="cov0" title="0">{
                return display.ModeCard
        }</span>
        <span class="cov0" title="0">if getBool(cmd, "tree") </span><span class="cov0" title="0">{
                return display.ModeTree
        }</span>
        <span class="cov0" title="0">if getBool(cmd, "dashboard") </span><span class="cov0" title="0">{
                return display.ModeDashboard
        }</span>
        // Default to auto-detection
        <span class="cov0" title="0">return display.ModeAuto</span>
}

// listRegistryArchivesWithDisplay uses the new display system
func listRegistryArchivesWithDisplay(opts listFilters, mode display.Mode, metrics *debug.Metrics) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>
        // Initialize storage manager
        <span class="cov0" title="0">storageManager, err := storage.NewManager(cfg.Storage.ManagedPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize managed storage: %w", err)
        }</span>
        <span class="cov0" title="0">defer storageManager.Close()

        // Get archives based on filters
        var archives []*storage.Archive
        if opts.notUploaded </span><span class="cov0" title="0">{
                archives, err = storageManager.ListNotUploaded()
        }</span> else<span class="cov0" title="0"> if opts.olderThan != "" </span><span class="cov0" title="0">{
                dur, parseErr := parseHumanDuration(opts.olderThan)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid duration format: %w", parseErr)
                }</span>
                <span class="cov0" title="0">archives, err = storageManager.ListOlderThan(dur)</span>
        } else<span class="cov0" title="0"> {
                archives, err = storageManager.List()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list archives: %w", err)
        }</span>

        // Record query completion if metrics enabled
        <span class="cov0" title="0">if metrics != nil </span><span class="cov0" title="0">{
                metrics.RecordQueryTime()
                metrics.SetResultCount(len(archives))
                
                // Get database size if available
                if dbInfo, statErr := os.Stat(filepath.Join(cfg.Storage.ManagedPath, "registry.db")); statErr == nil </span><span class="cov0" title="0">{
                        metrics.SetDatabaseSize(dbInfo.Size())
                }</span>
        }

        // Apply filters
        <span class="cov0" title="0">archives = applyAllFilters(archives, opts)

        // Use enhanced display system for supported modes
        if mode == display.ModeTable || mode == display.ModeCompact || mode == display.ModeCard || mode == display.ModeTree || mode == display.ModeDashboard </span><span class="cov0" title="0">{
                // Initialize display manager
                displayManager := display.NewManager()

                // Register available display modes
                tableDisplay := modes.NewTableDisplay()
                compactDisplay := modes.NewCompactDisplay()
                cardDisplay := modes.NewCardDisplay()
                treeDisplay := modes.NewTreeDisplay()
                dashboardDisplay := modes.NewDashboardDisplay()
                displayManager.Register(display.ModeTable, tableDisplay)
                displayManager.Register(display.ModeCompact, compactDisplay)
                displayManager.Register(display.ModeCard, cardDisplay)
                displayManager.Register(display.ModeTree, treeDisplay)
                displayManager.Register(display.ModeDashboard, dashboardDisplay)

                // Configure display options
                displayOpts := display.Options{
                        Mode:        mode,
                        Details:     opts.details,
                        ShowHeaders: mode != display.ModeCompact, // No headers for compact by default
                }

                // Render using the display system
                err := displayManager.Render(archives, displayOpts)
                
                // Record render time and show debug output if enabled
                if metrics != nil </span><span class="cov0" title="0">{
                        metrics.RecordRenderTime()
                        if opts.debug </span><span class="cov0" title="0">{
                                fmt.Printf("\n%s\n", metrics.String())
                        }</span>
                }
                
                <span class="cov0" title="0">return err</span>
        }

        // Fall back to original display for now (other modes not yet implemented)
        <span class="cov0" title="0">err = displayArchivesOriginal(archives, opts)
        
        // Show debug output for fallback display too
        if metrics != nil &amp;&amp; opts.debug </span><span class="cov0" title="0">{
                fmt.Printf("\n%s\n", metrics.String())
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

// applyAllFilters applies all configured filters to the archive list
func applyAllFilters(archives []*storage.Archive, opts listFilters) []*storage.Archive <span class="cov0" title="0">{
        // Apply pattern filter
        if opts.pattern != "" </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if matched, _ := filepath.Match(opts.pattern, a.Name); matched </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }

        // Apply managed/external filter
        <span class="cov0" title="0">if opts.onlyManaged || opts.onlyExternal </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if opts.onlyManaged &amp;&amp; a.Managed </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                        <span class="cov0" title="0">if opts.onlyExternal &amp;&amp; !a.Managed </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }

        // Apply missing filter
        <span class="cov0" title="0">if opts.onlyMissing </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if a.Status == "missing" </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }

        // Apply status/profile/larger-than filters
        <span class="cov0" title="0">archives = applyFilters(archives, struct {
                status, profile string
                largerThan      int64
        }{opts.status, opts.profile, opts.largerThan})

        return archives</span>
}

// displayArchivesOriginal is the original display function (fallback)
func displayArchivesOriginal(archives []*storage.Archive, opts listFilters) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found.\n")
                fmt.Printf("💡 Tip: Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Group and summarize
        <span class="cov0" title="0">var managedCount, externalCount, missingCount, deletedCount int
        var activeManaged, activeExternal, deletedArchives []*storage.Archive

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deletedCount++
                        deletedArchives = append(deletedArchives, a)
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedCount++
                        activeManaged = append(activeManaged, a)
                }</span> else<span class="cov0" title="0"> {
                        externalCount++
                        activeExternal = append(activeExternal, a)
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("📦 Archives (%d found)\n", len(archives))
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n\n",
                managedCount+externalCount, managedCount, externalCount, missingCount, deletedCount)

        // Delegate to existing printer
        return printGroupedArchives(archives, opts.details)</span>
}

func listRegistryArchives(opts listFilters) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>
        // Initialize storage manager
        <span class="cov0" title="0">storageManager, err := storage.NewManager(cfg.Storage.ManagedPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize managed storage: %w", err)
        }</span>
        <span class="cov0" title="0">defer storageManager.Close()

        // Get archives based on filters
        var archives []*storage.Archive
        if opts.notUploaded </span><span class="cov0" title="0">{
                archives, err = storageManager.ListNotUploaded()
        }</span> else<span class="cov0" title="0"> if opts.olderThan != "" </span><span class="cov0" title="0">{
                dur, parseErr := parseHumanDuration(opts.olderThan)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid duration format: %w", parseErr)
                }</span>
                <span class="cov0" title="0">archives, err = storageManager.ListOlderThan(dur)</span>
        } else<span class="cov0" title="0"> {
                archives, err = storageManager.List()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list archives: %w", err)
        }</span>

        // Apply pattern filter
        <span class="cov0" title="0">if opts.pattern != "" </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if matched, _ := filepath.Match(opts.pattern, a.Name); matched </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }
        // Apply managed/external filter
        <span class="cov0" title="0">if opts.onlyManaged || opts.onlyExternal </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if opts.onlyManaged &amp;&amp; a.Managed </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                        <span class="cov0" title="0">if opts.onlyExternal &amp;&amp; !a.Managed </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }
        // Apply missing filter
        <span class="cov0" title="0">if opts.onlyMissing </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range archives </span><span class="cov0" title="0">{
                        if a.Status == "missing" </span><span class="cov0" title="0">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }

        // Simple filter block (status/profile/larger-than)
        <span class="cov0" title="0">archives = applyFilters(archives, struct {
                status, profile string
                largerThan      int64
        }{opts.status, opts.profile, opts.largerThan})

        if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found.\n")
                fmt.Printf("💡 Tip: Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Group and summarize
        <span class="cov0" title="0">var managedCount, externalCount, missingCount, deletedCount int
        var activeManaged, activeExternal, deletedArchives []*storage.Archive

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deletedCount++
                        deletedArchives = append(deletedArchives, a)
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedCount++
                        activeManaged = append(activeManaged, a)
                }</span> else<span class="cov0" title="0"> {
                        externalCount++
                        activeExternal = append(activeExternal, a)
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("📦 Archives (%d found)\n", len(archives))
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n\n",
                managedCount+externalCount, managedCount, externalCount, missingCount, deletedCount)

        // Delegate to existing printer to keep behavior identical
        return printGroupedArchives(archives, opts.details)</span>
}

// applyFilters applies status/profile/largerThan filters in sequence
func applyFilters(archives []*storage.Archive, filters struct {
        status, profile string
        largerThan      int64
}) []*storage.Archive <span class="cov8" title="1">{
        result := archives
        if filters.status != "" </span><span class="cov8" title="1">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range result </span><span class="cov8" title="1">{
                        if a.Status == filters.status </span><span class="cov8" title="1">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov8" title="1">result = filtered</span>
        }
        <span class="cov8" title="1">if filters.profile != "" </span><span class="cov8" title="1">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range result </span><span class="cov8" title="1">{
                        if a.Profile == filters.profile </span><span class="cov8" title="1">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov8" title="1">result = filtered</span>
        }
        <span class="cov8" title="1">if filters.largerThan &gt; 0 </span><span class="cov8" title="1">{
                filtered := make([]*storage.Archive, 0)
                for _, a := range result </span><span class="cov8" title="1">{
                        if a.Size &gt; filters.largerThan </span><span class="cov8" title="1">{
                                filtered = append(filtered, a)
                        }</span>
                }
                <span class="cov8" title="1">result = filtered</span>
        }
        <span class="cov8" title="1">return result</span>
}

// printGroupedArchives prints groups and summary (same behavior as before)
func printGroupedArchives(archives []*storage.Archive, details bool) error <span class="cov0" title="0">{
        // Group and summarize
        var managedCount, externalCount, missingCount, deletedCount int
        var activeManaged, activeExternal, deletedArchives []*storage.Archive

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deletedCount++
                        deletedArchives = append(deletedArchives, a)
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedCount++
                        activeManaged = append(activeManaged, a)
                }</span> else<span class="cov0" title="0"> {
                        externalCount++
                        activeExternal = append(activeExternal, a)
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("📦 Archives (%d found)\n", len(archives))
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n\n",
                managedCount+externalCount, managedCount, externalCount, missingCount, deletedCount)

        // Print active archives
        if len(activeManaged) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("ACTIVE - MANAGED\n")
                printArchiveTable(activeManaged, details)
        }</span>
        <span class="cov0" title="0">if len(activeExternal) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("ACTIVE - EXTERNAL\n")
                printArchiveTable(activeExternal, details)
        }</span>

        // Print deleted archives
        <span class="cov0" title="0">if len(deletedArchives) &gt; 0 </span><span class="cov0" title="0">{
                // Load config to get actual retention days
                cfg, _ := config.Load()
                retentionDays := 7 // default fallback
                if cfg != nil &amp;&amp; cfg.Storage.RetentionDays &gt; 0 </span><span class="cov0" title="0">{
                        retentionDays = cfg.Storage.RetentionDays

                }</span>
                <span class="cov0" title="0">fmt.Printf("DELETED (auto-purge older than %d days)\n", retentionDays)
                for _, a := range deletedArchives </span><span class="cov0" title="0">{
                        displayDeletedArchive(a, details)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func printArchiveTable(archives []*storage.Archive, details bool) <span class="cov0" title="0">{
        // Headers
        if details </span><span class="cov0" title="0">{
                fmt.Printf("%-12s  %-30s  %8s  %-10s  %-19s  %-7s\n", "ID", "Name", "Size", "Profile", "Created", "Status")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%-12s  %-30s  %8s  %-7s\n", "ID", "Name", "Size", "Status")
        }</span>
        <span class="cov0" title="0">for _, a := range archives </span><span class="cov0" title="0">{
                id := a.UID
                if len(id) &gt; 12 </span><span class="cov0" title="0">{
                        id = id[:12]
                }</span>
                <span class="cov0" title="0">sizeMB := fmt.Sprintf("%.1f MB", float64(a.Size)/(1024*1024))
                status := a.Status
                if status == "present" </span><span class="cov0" title="0">{
                        status = "✓"
                }</span> else<span class="cov0" title="0"> if status == "missing" </span><span class="cov0" title="0">{
                        status = "⚠️"
                }</span>
                <span class="cov0" title="0">if details </span><span class="cov0" title="0">{
                        created := a.Created.Format("2006-01-02 15:04:05")
                        name := a.Name
                        if len(name) &gt; 30 </span><span class="cov0" title="0">{
                                name = name[:29] + "…"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("%-12s  %-30s  %8s  %-10s  %-19s  %-7s\n", id, name, sizeMB, a.Profile, created, status)</span>
                } else<span class="cov0" title="0"> {
                        name := a.Name
                        if len(name) &gt; 30 </span><span class="cov0" title="0">{
                                name = name[:29] + "…"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("%-12s  %-30s  %8s  %-7s\n", id, name, sizeMB, status)</span>
                }
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

func listManagedArchives(details, notUploaded bool, pattern, olderThan string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Initialize storage manager
        <span class="cov0" title="0">storageManager, err := storage.NewManager(cfg.Storage.ManagedPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize managed storage: %w", err)
        }</span>
        <span class="cov0" title="0">defer storageManager.Close()

        // Get archives based on filters
        var archives []*storage.Archive
        if notUploaded </span><span class="cov0" title="0">{
                archives, err = storageManager.ListNotUploaded()
        }</span> else<span class="cov0" title="0"> if olderThan != "" </span><span class="cov0" title="0">{
                duration, parseErr := parseHumanDuration(olderThan)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid duration format: %w", parseErr)
                }</span>
                <span class="cov0" title="0">archives, err = storageManager.ListOlderThan(duration)</span>
        } else<span class="cov0" title="0"> {
                archives, err = storageManager.List()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list archives: %w", err)
        }</span>

        // Apply pattern filter if specified
        <span class="cov0" title="0">if pattern != "" </span><span class="cov0" title="0">{
                filtered := make([]*storage.Archive, 0)
                for _, archive := range archives </span><span class="cov0" title="0">{
                        if matched, _ := filepath.Match(pattern, archive.Name); matched </span><span class="cov0" title="0">{
                                filtered = append(filtered, archive)
                        }</span>
                }
                <span class="cov0" title="0">archives = filtered</span>
        }

        <span class="cov0" title="0">if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found in managed storage.\n")
                fmt.Printf("💡 Tip: Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Display results
        <span class="cov0" title="0">fmt.Printf("📦 Managed Archives (%d found)\n", len(archives))
        fmt.Printf("Location: %s\n\n", storageManager.GetArchivesPath())

        for _, archive := range archives </span><span class="cov0" title="0">{
                displayArchive(archive, details)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func listDirectory(directory string, details bool, pattern string) error <span class="cov0" title="0">{
        fmt.Printf("📁 Listing .7z files in: %s\n\n", directory)

        // Find .7z files in directory
        matches, err := filepath.Glob(filepath.Join(directory, "*.7z"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan directory: %w", err)
        }</span>

        // Apply pattern filter if specified
        <span class="cov0" title="0">if pattern != "" </span><span class="cov0" title="0">{
                filtered := make([]string, 0)
                for _, match := range matches </span><span class="cov0" title="0">{
                        if matched, _ := filepath.Match(pattern, filepath.Base(match)); matched </span><span class="cov0" title="0">{
                                filtered = append(filtered, match)
                        }</span>
                }
                <span class="cov0" title="0">matches = filtered</span>
        }

        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No .7z files found.\n")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d archive(s):\n\n", len(matches))

        for _, archivePath := range matches </span><span class="cov0" title="0">{
                info, err := os.Stat(archivePath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("📦 %s\n", filepath.Base(archivePath))
                if details </span><span class="cov0" title="0">{
                        fmt.Printf("   Path: %s\n", archivePath)
                        fmt.Printf("   Size: %.2f MB\n", float64(info.Size())/(1024*1024))
                        fmt.Printf("   Created: %s\n", info.ModTime().Format("2006-01-02 15:04:05"))
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func displayArchive(archive *storage.Archive, details bool) <span class="cov0" title="0">{
        // Show upload status
        status := "📤 Not uploaded"
        if archive.Uploaded </span><span class="cov0" title="0">{
                status = "✅ Uploaded"
                if archive.Destination != "" </span><span class="cov0" title="0">{
                        status += fmt.Sprintf(" to %s", archive.Destination)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("📦 %s - %s\n", archive.Name, status)

        if details </span><span class="cov0" title="0">{
                if archive.UID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   ID: %s\n", archive.UID)
                }</span>
                <span class="cov0" title="0">fmt.Printf("   Path: %s\n", archive.Path)
                fmt.Printf("   Size: %.2f MB\n", float64(archive.Size)/(1024*1024))
                fmt.Printf("   Created: %s\n", archive.Created.Format("2006-01-02 15:04:05"))
                if archive.Profile != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Profile: %s\n", archive.Profile)
                }</span>
                <span class="cov0" title="0">if archive.Uploaded &amp;&amp; archive.UploadedAt != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   Uploaded: %s\n", archive.UploadedAt.Format("2006-01-02 15:04:05"))
                }</span>
                <span class="cov0" title="0">fmt.Printf("   Age: %s\n", formatDuration(archive.Age()))</span>
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

func displayDeletedArchive(archive *storage.Archive, details bool) <span class="cov0" title="0">{
        // Show deleted status with trash emoji
        deleteTime := "unknown"
        if archive.DeletedAt != nil </span><span class="cov0" title="0">{
                deleteTime = archive.DeletedAt.Format("2006-01-02 15:04:05")
        }</span>
        <span class="cov0" title="0">fmt.Printf("🗑️  %s - Deleted %s\n", archive.Name, deleteTime)

        if details </span><span class="cov0" title="0">{
                if archive.UID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   ID: %s\n", archive.UID)
                }</span>

                // Calculate days until auto-purge
                <span class="cov0" title="0">if archive.DeletedAt != nil </span><span class="cov0" title="0">{
                        cfg, _ := config.Load()
                        retentionDays := 7 // default fallback
                        if cfg != nil &amp;&amp; cfg.Storage.RetentionDays &gt; 0 </span><span class="cov0" title="0">{
                                retentionDays = cfg.Storage.RetentionDays
                        }</span>

                        <span class="cov0" title="0">purgeDate := archive.DeletedAt.AddDate(0, 0, retentionDays)
                        daysLeft := int(time.Until(purgeDate).Hours() / 24)

                        if daysLeft &gt; 1 </span><span class="cov0" title="0">{
                                fmt.Printf("   Auto-purge: %d days (%s)\n", daysLeft, purgeDate.Format("2006-01-02"))
                        }</span> else<span class="cov0" title="0"> if daysLeft == 1 </span><span class="cov0" title="0">{
                                fmt.Printf("   Auto-purge: 1 day (%s)\n", purgeDate.Format("2006-01-02"))
                        }</span> else<span class="cov0" title="0"> if daysLeft == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Auto-purge: today\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("   Auto-purge: overdue by %d days\n", -daysLeft)
                        }</span>
                }

                <span class="cov0" title="0">if archive.OriginalPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Original: %s\n", archive.OriginalPath)
                }</span>
                <span class="cov0" title="0">fmt.Printf("   Trash: %s\n", archive.Path)
                fmt.Printf("   Size: %.2f MB\n", float64(archive.Size)/(1024*1024))
                if archive.Profile != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Profile: %s\n", archive.Profile)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", int(d.Minutes()))
        }</span>
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", int(d.Hours()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dd", int(d.Hours()/24))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/adamstac/7zarch-go/internal/config"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

func MasDbCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{Use: "db", Short: "Database operations (status, migrate, backup)"}
        cmd.AddCommand(masDbStatusCmd())
        cmd.AddCommand(masDbMigrateCmd())
        cmd.AddCommand(masDbBackupCmd())
        return cmd
}</span>

func masDbStatusCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Show database version and applied migrations",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer mgr.Close()

                        if err := mgr.Registry().EnsureMigrationsTable(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // For now, we show whether baseline/identity are marked
                        <span class="cov0" title="0">baseApplied, _ := mgr.Registry().IsMigrationApplied("0001_baseline")
                        idApplied, _ := mgr.Registry().IsMigrationApplied("0002_identity_and_status")
                        fmt.Printf("DB Path: %s\n", mgr.Registry().Path())
                        fmt.Printf("Baseline: %v\n", baseApplied)
                        fmt.Printf("Identity/Status: %v\n", idApplied)
                        return nil</span>
                },
        }
}

func masDbMigrateCmd() *cobra.Command <span class="cov0" title="0">{
        var dryRun bool
        var backupOnly bool
        cmd := &amp;cobra.Command{
                Use:   "migrate",
                Short: "Apply pending migrations",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer mgr.Close()

                        if backupOnly </span><span class="cov0" title="0">{
                                return createDbBackup(mgr)
                        }</span>
                        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                                fmt.Println("Dry run: no migrations applied")
                                return nil
                        }</span>
                        // For now, schema is current; future pending migrations will be run here
                        <span class="cov0" title="0">fmt.Println("No pending migrations")
                        return nil</span>
                },
        }
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be done")
        cmd.Flags().BoolVar(&amp;backupOnly, "backup-only", false, "Create a backup without migrating")
        return cmd</span>
}

func masDbBackupCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "backup",
                Short: "Create a timestamped backup of the registry database",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer mgr.Close()
                        return createDbBackup(mgr)</span>
                },
        }
}

func createDbBackup(mgr *storage.Manager) error <span class="cov0" title="0">{
        path := mgr.Registry().Path()
        if path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("registry path unknown")
        }</span>
        <span class="cov0" title="0">backupDir := filepath.Dir(path)
        stamp := time.Now().Format("20060102-150405")
        backupPath := filepath.Join(backupDir, fmt.Sprintf("registry.%s.bak", stamp))

        // #nosec G304: path comes from validated config; used for local backup
        src, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer src.Close()
        // Use restrictive permissions for backup file
        // #nosec G304: backupPath is created under the same directory as the DB
        dst, err := os.OpenFile(backupPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer dst.Close()
        if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Backup created: %s\n", backupPath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/adamstac/7zarch-go/internal/cmdutil"
        errs "github.com/adamstac/7zarch-go/internal/errors"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

func MasDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool
        cmd := &amp;cobra.Command{
                Use:   "delete &lt;id&gt;",
                Short: "Delete an archive (soft by default; --force to remove file)",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        id := args[0]
                        _, mgr, cleanup, err := cmdutil.InitStorageManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer cleanup()

                        resolver := storage.NewResolver(mgr.Registry())
                        arc, err := resolver.Resolve(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return cmdutil.HandleResolverError(err, id)
                        }</span>
                        
                        // Check if already deleted
                        <span class="cov0" title="0">if arc.Status == "deleted" </span><span class="cov0" title="0">{
                                return &amp;errs.InvalidOperationError{
                                        Operation: "delete",
                                        Resource:  "archive",
                                        Reason:    "archive is already deleted",
                                }
                        }</span>

                        <span class="cov0" title="0">now := time.Now()
                        orig := arc.Path

                        if force </span><span class="cov0" title="0">{
                                // Physically remove file if present
                                _ = os.Remove(arc.Path)
                                arc.Status = "deleted"
                                arc.DeletedAt = &amp;now
                                if arc.OriginalPath == "" </span><span class="cov0" title="0">{
                                        arc.OriginalPath = orig
                                }</span>
                                <span class="cov0" title="0">return mgr.Registry().Update(arc)</span>
                        }

                        // Soft delete
                        <span class="cov0" title="0">if arc.Managed </span><span class="cov0" title="0">{
                                // Move to managed trash directory
                                trashDir := mgr.GetTrashPath()
                                // #nosec G301: restrict permissions on created trash directory
                                if err := os.MkdirAll(trashDir, 0750); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create trash: %w", err)
                                }</span>
                                <span class="cov0" title="0">trashPath := filepath.Join(trashDir, filepath.Base(arc.Path))
                                if err := moveOrCopy(arc.Path, trashPath); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to move to trash: %w", err)
                                }</span>
                                <span class="cov0" title="0">arc.Path = trashPath</span>
                        } else <span class="cov0" title="0">{
                                // External: default DB-only delete (do not touch file)
                        }</span>
                        <span class="cov0" title="0">arc.Status = "deleted"
                        arc.DeletedAt = &amp;now
                        if arc.OriginalPath == "" </span><span class="cov0" title="0">{
                                arc.OriginalPath = orig
                        }</span>
                        <span class="cov0" title="0">return mgr.Registry().Update(arc)</span>
                },
        }
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;force, "force", false, "Physically remove file instead of soft delete")
        return cmd</span>
}

// moveOrCopy tries to rename; if it fails (e.g., cross-device), it copies then removes
func moveOrCopy(src, dst string) error <span class="cov8" title="1">{
        if err := os.Rename(src, dst); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // fallback to copy + remove
        // #nosec G304: src and dst are derived from managed paths within storage; validated upstream
        <span class="cov8" title="1">srcF, err := os.Open(src)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">defer srcF.Close()
        // Use restrictive permissions for destination file
        // #nosec G304: destination is inside managed trash or archives path
        dstF, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer dstF.Close()
        if _, err := io.Copy(dstF, srcF); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Remove(src)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/adamstac/7zarch-go/internal/cmdutil"
        errs "github.com/adamstac/7zarch-go/internal/errors"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

// copyFile copies src to dst with mode preservation
func copyFile(src, dst string) error <span class="cov0" title="0">{
        // #nosec G304: src/dst validated via resolver and managed paths
        in, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer in.Close()

        // Use restrictive permissions for new file
        // #nosec G304: destination path validated/constructed earlier and rooted within managed base when applicable
        out, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        if _, err = io.Copy(out, in); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = out.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if info, err := os.Stat(src); err == nil </span><span class="cov0" title="0">{
                _ = os.Chmod(dst, info.Mode())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func MasMoveCmd() *cobra.Command <span class="cov0" title="0">{
        var to string
        cmd := &amp;cobra.Command{
                Use:   "move &lt;id&gt;",
                Short: "Move an archive (default to managed storage if --to omitted)",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        id := args[0]
                        _, mgr, cleanup, err := cmdutil.InitStorageManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer cleanup()

                        resolver := storage.NewResolver(mgr.Registry())
                        arc, err := resolver.Resolve(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return cmdutil.HandleResolverError(err, id)
                        }</span>
                        
                        // Check if archive can be moved
                        <span class="cov0" title="0">if arc.Status == "deleted" </span><span class="cov0" title="0">{
                                return &amp;errs.InvalidOperationError{
                                        Operation: "move",
                                        Resource:  "archive",
                                        Reason:    "archive is deleted",
                                }
                        }</span>

                        <span class="cov0" title="0">dest := to
                        if dest == "" </span><span class="cov0" title="0">{

                                name := arc.Name
                                if name == "" </span><span class="cov0" title="0">{
                                        name = filepath.Base(arc.Path)
                                }</span>
                                <span class="cov0" title="0">dest = mgr.GetManagedPath(name)</span>
                        }

                        // If dest is an existing directory, place the file under it by name
                        <span class="cov0" title="0">if info, err := os.Stat(dest); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                name := arc.Name
                                if name == "" </span><span class="cov0" title="0">{
                                        name = filepath.Base(arc.Path)
                                }</span>
                                <span class="cov0" title="0">dest = filepath.Join(dest, name)</span>
                        }

                        // #nosec G301: restrict permissions on created directory
                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(dest), 0750); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Prevent accidental overwrite
                        <span class="cov0" title="0">if info, err := os.Stat(dest); err == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                                return fmt.Errorf("destination file already exists: %s", dest)
                        }</span>

                        <span class="cov0" title="0">if err := os.Rename(arc.Path, dest); err != nil </span><span class="cov0" title="0">{
                                // Handle cross-device rename (EXDEV)
                                var linkErr *os.LinkError
                                if errors.As(err, &amp;linkErr) &amp;&amp; errors.Is(linkErr.Err, syscall.EXDEV) </span><span class="cov0" title="0">{
                                        if err := copyFile(arc.Path, dest); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("copy fallback failed: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">if err := os.Remove(arc.Path); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("cleanup source failed after copy: %w", err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }

                        <span class="cov0" title="0">arc.Path = dest
                        // More precise managed-path check
                        rel, _ := filepath.Rel(mgr.GetBasePath(), dest)
                        up := ".." + string(os.PathSeparator)
                        arc.Managed = rel != ".." &amp;&amp; !strings.HasPrefix(rel, up)

                        return mgr.Registry().Update(arc)</span>
                },
        }
        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;to, "to", "", "Destination path or managed default if omitted")
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/adamstac/7zarch-go/internal/cmdutil"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

func MasShowCmd() *cobra.Command <span class="cov0" title="0">{
        var verify bool
        cmd := &amp;cobra.Command{
                Use:   "show &lt;id&gt;",
                Short: "Show archive details by ID (uid, checksum prefix, numeric id, or name)",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        id := args[0]
                        _, mgr, cleanup, err := cmdutil.InitStorageManager()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer cleanup()

                        resolver := storage.NewResolver(mgr.Registry())
                        arc, err := resolver.Resolve(id)
                        if err != nil </span><span class="cov0" title="0">{
                                if amb, ok := err.(*storage.AmbiguousIDError); ok </span><span class="cov0" title="0">{
                                        printAmbiguousOptions(amb)
                                }</span>
                                <span class="cov0" title="0">return cmdutil.HandleResolverError(err, id)</span>
                        }

                        // File existence verification + last_seen/status update
                        <span class="cov0" title="0">now := time.Now()
                        if _, statErr := os.Stat(arc.Path); statErr == nil </span><span class="cov0" title="0">{
                                arc.Status = "present"
                        }</span> else<span class="cov0" title="0"> {
                                arc.Status = "missing"
                        }</span>
                        <span class="cov0" title="0">arc.LastSeen = &amp;now
                        _ = mgr.Registry().Update(arc)

                        printArchive(arc, verify)
                        return nil</span>
                },
        }
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;verify, "verify", false, "Verify checksum against file (slower)")
        return cmd</span>
}

func printArchive(a *storage.Archive, verify bool) <span class="cov0" title="0">{
        status := a.Status
        switch status </span>{
        case "present":<span class="cov0" title="0">
                status += " ✓"</span>
        case "missing":<span class="cov0" title="0">
                status += " ⚠️"</span>
        }
        <span class="cov0" title="0">fmt.Printf("UID:        %s\n", a.UID)
        fmt.Printf("Name:       %s\n", a.Name)
        fmt.Printf("Path:       %s\n", a.Path)
        fmt.Printf("Managed:    %t\n", a.Managed)
        fmt.Printf("Status:     %s\n", status)
        fmt.Printf("Size:       %d\n", a.Size)
        fmt.Printf("Created:    %s\n", a.Created.Format("2006-01-02 15:04:05"))
        // Checksum line
        if a.Checksum == "" </span><span class="cov0" title="0">{
                fmt.Printf("Checksum:   (none)\n")
        }</span> else<span class="cov0" title="0"> if verify &amp;&amp; a.Status == "present" </span><span class="cov0" title="0">{
                computed, err := computeSHA256(a.Path)
                if err == nil &amp;&amp; computed == a.Checksum </span><span class="cov0" title="0">{
                        fmt.Printf("Checksum:   %s (verified ✓)\n", a.Checksum)
                }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("Checksum:   %s (mismatch ⚠️)\n", a.Checksum)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Checksum:   %s (verify error: %v)\n", a.Checksum, err)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Checksum:   %s\n", a.Checksum)
        }</span>
        <span class="cov0" title="0">if a.Profile != "" </span><span class="cov0" title="0">{
                fmt.Printf("Profile:    %s\n", a.Profile)
        }</span>
        <span class="cov0" title="0">if a.Uploaded </span><span class="cov0" title="0">{
                fmt.Printf("Uploaded:   %t (%s)\n", a.Uploaded, a.Destination)
        }</span>
}

func computeSHA256(path string) (string, error) <span class="cov0" title="0">{
        // #nosec G304: path originates from registry-managed archive object
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        h := sha256.New()
        if _, err := io.Copy(h, f); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

func printAmbiguousOptions(amb *storage.AmbiguousIDError) <span class="cov0" title="0">{
        fmt.Printf("Multiple archives match '%s':\n", amb.ID)
        for i, a := range amb.Matches </span><span class="cov0" title="0">{
                loc := "external"
                if a.Managed </span><span class="cov0" title="0">{
                        loc = "managed"
                }</span>
                <span class="cov0" title="0">age := time.Since(a.Created).Round(time.Hour)
                fmt.Printf("[%d] %s  %s  (%s, %.1f MB, %s ago)\n", i+1, safePrefix(a.UID, 8), a.Name, loc, float64(a.Size)/(1024*1024), age)</span>
        }
        <span class="cov0" title="0">fmt.Println("Please specify a longer prefix or the full UID.")</span>
}

func safePrefix(s string, n int) string <span class="cov0" title="0">{
        if len(s) &lt;= n </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:n]</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "sort"

        "github.com/adamstac/7zarch-go/internal/archive"
        "github.com/spf13/cobra"
)

func ProfilesCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "profiles",
                Short: "List available compression profiles",
                Long:  `List all available compression profiles with their settings and recommended use cases.`,
                RunE:  runProfiles,
        }

        return cmd
}</span>

func runProfiles(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        profiles := archive.ListProfiles()

        // Sort profiles by name for consistent output
        sort.Slice(profiles, func(i, j int) bool </span><span class="cov0" title="0">{
                return profiles[i].Name &lt; profiles[j].Name
        }</span>)

        <span class="cov0" title="0">out := cmd.OutOrStdout()
        fmt.Fprintf(out, "Available Compression Profiles\n")
        fmt.Fprintf(out, "==============================\n\n")

        if len(profiles) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(out, "No compression profiles found.\n")
                fmt.Fprintf(out, "Tip: Use smart defaults or specify --compression to override.\n")
                return nil
        }</span>

        <span class="cov0" title="0">for _, profile := range profiles </span><span class="cov0" title="0">{
                fmt.Fprintf(out, "📦 %s\n", profile.Name)
                fmt.Fprintf(out, "   %s\n", profile.Description)
                fmt.Fprintf(out, "   Settings: Level %d, Dictionary %s, Fast bytes %d",
                        profile.Level, profile.DictionarySize, profile.FastBytes)

                if profile.SolidMode </span><span class="cov0" title="0">{
                        fmt.Fprintf(out, ", Solid mode on\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(out, ", Solid mode off\n")
                }</span>

                // Add usage examples
                <span class="cov0" title="0">switch profile.Name </span>{
                case "Media":<span class="cov0" title="0">
                        fmt.Fprintf(out, "   Best for: Video files, audio files, photos, podcasts\n")
                        fmt.Fprintf(out, "   Example: 7zarch-go create video-project --profile media\n")</span>
                case "Documents":<span class="cov0" title="0">
                        fmt.Fprintf(out, "   Best for: Text files, source code, office documents, PDFs\n")
                        fmt.Fprintf(out, "   Example: 7zarch-go create source-code --profile documents\n")</span>
                case "Balanced":<span class="cov0" title="0">
                        fmt.Fprintf(out, "   Best for: Mixed content, general backups\n")
                        fmt.Fprintf(out, "   Example: 7zarch-go create backup-folder --profile balanced\n")</span>
                }

                <span class="cov0" title="0">fmt.Fprintf(out, "\n")</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(out, "Smart Compression (Default Behavior)\n")
        fmt.Fprintf(out, "====================================\n")
        fmt.Fprintf(out, "7zarch-go is smart by default - it analyzes your content and automatically\n")
        fmt.Fprintf(out, "selects the best profile for optimal performance:\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder\n\n")

        fmt.Fprintf(out, "Manual Profile Override\n")
        fmt.Fprintf(out, "=======================\n")
        fmt.Fprintf(out, "Force a specific profile when you know what you want:\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder --profile media\n\n")

        fmt.Fprintf(out, "Traditional Compression Level\n")
        fmt.Fprintf(out, "=============================\n")
        fmt.Fprintf(out, "Use traditional compression level (0-9) to disable smart behavior:\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder --compression 9\n\n")

        fmt.Fprintf(out, "Presets\n")
        fmt.Fprintf(out, "=======\n")
        fmt.Fprintf(out, "Use predefined combinations of settings for common workflows:\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder --preset podcast\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder --preset backup\n")
        fmt.Fprintf(out, "   7zarch-go create my-folder --preset source_code\n")
        fmt.Fprintf(out, "\nRun '7zarch-go config show' to see available presets in your configuration.\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/adamstac/7zarch-go/internal/config"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

// RestoreCmd returns the `restore` command.
// Usage: 7zarch-go restore &lt;id&gt;
func RestoreCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                flagForce  bool
                flagDryRun bool
        )

        cmd := &amp;cobra.Command{
                Use:   "restore &lt;id&gt;",
                Short: "Restore a deleted archive from trash",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        id := args[0]
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to init storage: %w", err)
                        }</span>
                        <span class="cov8" title="1">defer mgr.Close()

                        resolver := storage.NewResolver(mgr.Registry())
                        arc, err := resolver.Resolve(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if arc.Status != "deleted" </span><span class="cov0" title="0">{
                                return fmt.Errorf("archive '%s' is not deleted (status=%s)", arc.Name, arc.Status)
                        }</span>

                        <span class="cov8" title="1">target := arc.OriginalPath
                        if target == "" </span><span class="cov8" title="1">{
                                name := arc.Name
                                if name == "" </span><span class="cov0" title="0">{
                                        name = filepath.Base(arc.Path)
                                }</span>
                                <span class="cov8" title="1">target = mgr.GetManagedPath(name)</span>
                        }

                        // Plan
                        <span class="cov8" title="1">if flagDryRun </span><span class="cov0" title="0">{
                                cmd.Printf("Would restore %s -&gt; %s\n", arc.Path, target)
                                return nil
                        }</span>

                        // Ensure parent dir exists
                        // #nosec G301: restrict permissions on restored directory
                        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(target), 0750); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to prepare destination: %w", err)
                        }</span>

                        // If managed archive, file lives in trash and needs moving back
                        <span class="cov8" title="1">if arc.Managed </span><span class="cov8" title="1">{
                                if err := moveOrCopy(arc.Path, target); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed to restore file: %w", err)
                                }</span>
                                <span class="cov8" title="1">arc.Path = target</span>
                        } else<span class="cov8" title="1"> {
                                // External soft delete: file likely remained in place; just flip status
                                arc.Path = target
                        }</span>

                        // Update registry state
                        <span class="cov8" title="1">arc.Status = "present"
                        arc.DeletedAt = nil
                        now := time.Now()
                        arc.LastSeen = &amp;now
                        if err := mgr.Registry().Update(arc); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update registry: %w", err)
                        }</span>
                        <span class="cov8" title="1">cmd.Printf("✅ Restored %s to %s\n", arc.Name, target)
                        return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;flagForce, "force", false, "Overwrite existing file if it exists at original location")
        cmd.Flags().BoolVar(&amp;flagDryRun, "dry-run", false, "Show actions without making changes")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/adamstac/7zarch-go/internal/archive"
        "github.com/schollz/progressbar/v3"
        "github.com/spf13/cobra"
        "golang.org/x/sync/errgroup"
)

var (
        testRemote    bool
        testDirectory bool
        maxConcurrent int
)

func TestCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "test &lt;archive|directory&gt;",
                Short: "Test archive integrity",
                Long: `Test the integrity of archives by verifying structure, checksums, and metadata.
Can test single archives or entire directories concurrently.`,
                Args: cobra.ExactArgs(1),
                RunE: runTest,
        }

        // Add flags
        cmd.Flags().BoolVar(&amp;testRemote, "remote", false, "Run tests on TrueNAS server")
        cmd.Flags().BoolVarP(&amp;testDirectory, "directory", "d", false, "Test all archives in directory")
        cmd.Flags().IntVar(&amp;maxConcurrent, "concurrent", 10, "Max concurrent tests")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be tested")

        return cmd
}</span>

func runTest(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        target := args[0]

        if dryRun </span><span class="cov0" title="0">{
                return runTestDryRun(target)
        }</span>

        <span class="cov0" title="0">if testDirectory </span><span class="cov0" title="0">{
                return runTestDirectory(target)
        }</span>

        <span class="cov0" title="0">return runTestSingle(target)</span>
}

func runTestDryRun(target string) error <span class="cov0" title="0">{
        fmt.Printf("DRY RUN MODE - No tests will be executed\n\n")

        if testDirectory </span><span class="cov0" title="0">{
                // Find archives in directory
                archives, err := findArchives(target)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find archives: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Would test %d archives in %s:\n", len(archives), target)
                for _, arch := range archives </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s\n", filepath.Base(arch))
                }</span>
                <span class="cov0" title="0">fmt.Printf("\nTests to run:\n")
                fmt.Printf("  ✓ Archive structure integrity\n")
                fmt.Printf("  ✓ Checksum verification\n")
                fmt.Printf("  ✓ Metadata validation\n")
                fmt.Printf("  ✓ Extraction test\n")
                fmt.Printf("\nMax concurrent tests: %d\n", maxConcurrent)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Would test archive: %s\n", target)
                fmt.Printf("\nTests to run:\n")
                fmt.Printf("  ✓ Archive structure integrity\n")
                fmt.Printf("  ✓ Checksum verification\n")
                fmt.Printf("  ✓ Metadata validation\n")
                fmt.Printf("  ✓ Extraction test\n")
        }</span>

        <span class="cov0" title="0">if testRemote </span><span class="cov0" title="0">{
                fmt.Printf("\nExecution mode: Remote (on TrueNAS)\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\nExecution mode: Local\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runTestSingle(archivePath string) error <span class="cov0" title="0">{
        fmt.Printf("Testing archive: %s\n\n", filepath.Base(archivePath))

        manager := archive.NewManager()
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
        defer cancel()

        // Run tests
        result, err := manager.Test(ctx, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("test failed: %w", err)
        }</span>

        // Display results
        <span class="cov0" title="0">printTestResult(archivePath, result)

        if !result.Passed </span><span class="cov0" title="0">{
                return fmt.Errorf("archive verification failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runTestDirectory(dir string) error <span class="cov0" title="0">{
        // Find all archives
        archives, err := findArchives(dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find archives: %w", err)
        }</span>

        <span class="cov0" title="0">if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found in %s\n", dir)
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Testing %d archives in %s\n\n", len(archives), dir)

        // Create progress bar
        bar := progressbar.Default(int64(len(archives)))

        // Results storage
        results := make([]*archive.TestResult, len(archives))
        var resultsMu sync.Mutex

        // Run tests concurrently
        g, ctx := errgroup.WithContext(context.Background())
        g.SetLimit(maxConcurrent)

        for i, archivePath := range archives </span><span class="cov0" title="0">{
                i, archivePath := i, archivePath // Capture loop variables

                g.Go(func() error </span><span class="cov0" title="0">{
                        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Test archive (per-archive timeout for parity with single mode)
                        <span class="cov0" title="0">manager := archive.NewManager()
                        ctxArchive, cancel := context.WithTimeout(ctx, 10*time.Minute)
                        defer cancel()
                        result, err := manager.Test(ctxArchive, archivePath)
                        if err != nil </span><span class="cov0" title="0">{
                                result = &amp;archive.TestResult{
                                        Passed: false,
                                        Errors: []string{err.Error()},
                                }
                        }</span>

                        // Store result
                        <span class="cov0" title="0">resultsMu.Lock()
                        results[i] = result
                        _ = bar.Add(1) // best-effort UI update
                        resultsMu.Unlock()

                        return nil</span>
                })
        }

        // Wait for all tests to complete
        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("testing failed: %w", err)
        }</span>

        <span class="cov0" title="0">_ = bar.Finish() // best-effort UI cleanup
        fmt.Printf("\n")

        // Print summary
        printBatchSummary(archives, results)

        // Check if any failed
        failedCount := 0
        for _, result := range results </span><span class="cov0" title="0">{
                if !result.Passed </span><span class="cov0" title="0">{
                        failedCount++
                }</span>
        }

        <span class="cov0" title="0">if failedCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%d archives failed verification", failedCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func findArchives(dir string) ([]string, error) <span class="cov0" title="0">{
        var archives []string

        err := filepath.WalkDir(dir, func(path string, d os.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !d.IsDir() &amp;&amp; strings.EqualFold(filepath.Ext(path), ".7z") </span><span class="cov0" title="0">{
                        archives = append(archives, path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return archives, err</span>
}

func printTestResult(_ string, result *archive.TestResult) <span class="cov0" title="0">{
        if result.Passed </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Archive integrity verified\n")
                fmt.Printf("  Archive structure: VALID\n")
                if result.ChecksumValid </span><span class="cov0" title="0">{
                        fmt.Printf("  Checksums: ALL MATCH (%d files verified)\n", result.FilesVerified)
                }</span>
                <span class="cov0" title="0">if result.MetadataValid </span><span class="cov0" title="0">{
                        fmt.Printf("  Metadata: CONSISTENT\n")
                }</span>
                <span class="cov0" title="0">fmt.Printf("  Extraction: SUCCESS\n")
                fmt.Printf("  Completeness: ALL ARTIFACTS PRESENT\n")</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Archive verification failed\n")
                if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  Errors:\n")
                        for _, err := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("    - %s\n", err)
                        }</span>
                }
        }
        <span class="cov0" title="0">fmt.Printf("\n")</span>
}

func printBatchSummary(archives []string, results []*archive.TestResult) <span class="cov0" title="0">{
        passed := 0
        failed := 0
        totalFiles := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Passed </span><span class="cov0" title="0">{
                        passed++
                }</span> else<span class="cov0" title="0"> {
                        failed++
                }</span>
                <span class="cov0" title="0">totalFiles += result.FilesVerified</span>
        }

        <span class="cov0" title="0">fmt.Printf("Batch Summary:\n")
        fmt.Printf("- Total archives tested: %d\n", len(archives))
        fmt.Printf("- Passed: %d (%.1f%%)\n", passed, float64(passed)/float64(len(archives))*100)
        if failed &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("- Failed: %d (%.1f%%)\n", failed, float64(failed)/float64(len(archives))*100)

                // List failed archives
                fmt.Printf("\nFailed archives:\n")
                for i, result := range results </span><span class="cov0" title="0">{
                        if !result.Passed </span><span class="cov0" title="0">{
                                fmt.Printf("  ❌ %s\n", filepath.Base(archives[i]))
                        }</span>
                }
        }
        <span class="cov0" title="0">fmt.Printf("- Total files verified: %d\n", totalFiles)

        if passed == len(archives) </span><span class="cov0" title="0">{
                fmt.Printf("\n✅ All archives passed verification!\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/config"
        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/spf13/cobra"
)

// TrashCmd groups trash-related subcommands.
func TrashCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "trash",
                Short: "Manage deleted archives in trash",
        }
        cmd.AddCommand(trashListCmd())
        cmd.AddCommand(trashPurgeCmd())
        return cmd
}</span>

func trashListCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                flagWithinDays int
                flagBefore     string
                flagJSON       bool
        )
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List deleted archives and purge eligibility",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to init storage: %w", err)
                        }</span>
                        <span class="cov8" title="1">defer mgr.Close()

                        archives, err := mgr.List()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">var out []*storage.Archive
                        for _, a := range archives </span><span class="cov8" title="1">{
                                if a.Status != "deleted" </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if flagBefore != "" &amp;&amp; a.DeletedAt != nil </span><span class="cov8" title="1">{
                                        cutoff, err := parseYMD(flagBefore)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid --before date: %w", err)
                                        }</span>
                                        <span class="cov8" title="1">if a.DeletedAt.After(cutoff) </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">if flagWithinDays &gt; 0 &amp;&amp; a.DeletedAt != nil </span><span class="cov8" title="1">{
                                        purge := a.DeletedAt.Add(time.Duration(cfg.Storage.RetentionDays) * 24 * time.Hour)
                                        days := int(time.Until(purge).Hours() / 24)
                                        if days &gt; flagWithinDays </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">out = append(out, a)</span>
                        }

                        <span class="cov8" title="1">if flagJSON </span><span class="cov8" title="1">{
                                // Enrich with countdown
                                type row struct {
                                        UID       string     `json:"uid"`
                                        Name      string     `json:"name"`
                                        Path      string     `json:"path"`
                                        DeletedAt *time.Time `json:"deleted_at"`
                                        PurgeDate string     `json:"purge_date"`
                                        DaysLeft  int        `json:"days_left"`
                                }
                                rows := make([]row, 0, len(out))
                                for _, a := range out </span><span class="cov8" title="1">{
                                        var purgeStr string
                                        days := -1
                                        if a.DeletedAt != nil </span><span class="cov8" title="1">{
                                                purge := a.DeletedAt.Add(time.Duration(cfg.Storage.RetentionDays) * 24 * time.Hour)
                                                purgeStr = purge.Format("2006-01-02")
                                                days = int(time.Until(purge).Hours() / 24)
                                        }</span>
                                        <span class="cov8" title="1">rows = append(rows, row{UID: a.UID, Name: a.Name, Path: a.Path, DeletedAt: a.DeletedAt, PurgeDate: purgeStr, DaysLeft: days})</span>
                                }
                                <span class="cov8" title="1">enc := json.NewEncoder(cmd.OutOrStdout())
                                enc.SetIndent("", "  ")
                                return enc.Encode(rows)</span>
                        }

                        // Text output
                        <span class="cov8" title="1">outWriter := cmd.OutOrStdout()
                        fmt.Fprintf(outWriter, "🗑️  Deleted archives (%d)\n", len(out))
                        for _, a := range out </span><span class="cov8" title="1">{
                                var delStr, purgeStr, countdown string
                                if a.DeletedAt != nil </span><span class="cov8" title="1">{
                                        delStr = a.DeletedAt.Format("2006-01-02")
                                        purge := a.DeletedAt.Add(time.Duration(cfg.Storage.RetentionDays) * 24 * time.Hour)
                                        purgeStr = purge.Format("2006-01-02")
                                        days := int(time.Until(purge).Hours() / 24)
                                        if days &lt; 0 </span><span class="cov8" title="1">{
                                                countdown = "overdue"
                                        }</span> else<span class="cov8" title="1"> {
                                                countdown = fmt.Sprintf("%dd", days)
                                        }</span>
                                }
                                <span class="cov8" title="1">fmt.Fprintf(outWriter, "- %s (%s)\n  deleted: %s | purge: %s (%s)\n", a.Name, a.UID[:8], delStr, purgeStr, countdown)</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                },
        }
        <span class="cov8" title="1">cmd.Flags().IntVar(&amp;flagWithinDays, "within-days", 0, "Show items purging within N days (0=all)")
        cmd.Flags().StringVar(&amp;flagBefore, "before", "", "Only show items deleted before YYYY-MM-DD")
        cmd.Flags().BoolVar(&amp;flagJSON, "json", false, "Output as JSON")
        return cmd</span>
}

func trashPurgeCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                flagAll    bool
                flagForce  bool
                flagDryRun bool
                flagWithin int
        )
        cmd := &amp;cobra.Command{
                Use:   "purge",
                Short: "Permanently delete trashed archives past retention",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        cfg, _ := config.Load()
                        mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to init storage: %w", err)
                        }</span>
                        <span class="cov8" title="1">defer mgr.Close()

                        archives, err := mgr.List()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">var eligible []*storage.Archive
                        now := time.Now()
                        for _, a := range archives </span><span class="cov8" title="1">{
                                if a.Status != "deleted" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if a.DeletedAt == nil &amp;&amp; !flagAll </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">purgeDate := time.Time{}
                                if a.DeletedAt != nil </span><span class="cov8" title="1">{
                                        purgeDate = a.DeletedAt.Add(time.Duration(cfg.Storage.RetentionDays) * 24 * time.Hour)
                                }</span>
                                // Eligibility
                                <span class="cov8" title="1">if flagAll </span><span class="cov8" title="1">{
                                        eligible = append(eligible, a)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if flagWithin &gt; 0 </span><span class="cov8" title="1">{
                                        days := int(purgeDate.Sub(now).Hours() / 24)
                                        if days &lt;= flagWithin </span><span class="cov8" title="1">{
                                                eligible = append(eligible, a)
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                                <span class="cov8" title="1">if !purgeDate.IsZero() &amp;&amp; !purgeDate.After(now) </span><span class="cov8" title="1">{
                                        eligible = append(eligible, a)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(eligible) == 0 </span><span class="cov0" title="0">{
                                fmt.Fprintln(cmd.OutOrStdout(), "Nothing to purge.")
                                return nil
                        }</span>

                        // Confirmation unless --force
                        <span class="cov8" title="1">if !flagForce </span><span class="cov0" title="0">{
                                fmt.Fprintf(cmd.OutOrStdout(), "About to purge %d archives. Proceed? [y/N]: ", len(eligible))
                                reader := bufio.NewReader(os.Stdin)
                                line, _ := reader.ReadString('\n')
                                line = strings.TrimSpace(strings.ToLower(line))
                                if line != "y" &amp;&amp; line != "yes" </span><span class="cov0" title="0">{
                                        fmt.Fprintln(cmd.OutOrStdout(), "Aborted.")
                                        return nil
                                }</span>
                        }

                        // Dry-run summary
                        <span class="cov8" title="1">if flagDryRun </span><span class="cov8" title="1">{
                                fmt.Fprintf(cmd.OutOrStdout(), "Would purge %d archives:\n", len(eligible))
                                for _, a := range eligible </span><span class="cov8" title="1">{
                                        fmt.Fprintf(cmd.OutOrStdout(), "- %s (%s)\n", a.Name, a.UID[:8])
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }

                        <span class="cov8" title="1">trashDir := mgr.GetTrashPath()
                        for _, a := range eligible </span><span class="cov8" title="1">{
                                // Remove file if it appears under trash (managed archives)
                                if a.Managed &amp;&amp; strings.HasPrefix(a.Path, trashDir+string(os.PathSeparator)) </span><span class="cov8" title="1">{
                                        _ = os.Remove(a.Path)
                                }</span>
                                // Remove from registry
                                <span class="cov8" title="1">_ = mgr.Registry().Delete(a.Name)</span>
                        }
                        <span class="cov8" title="1">fmt.Fprintf(cmd.OutOrStdout(), "Purged %d archives.\n", len(eligible))
                        return nil</span>
                },
        }
        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;flagAll, "all", false, "Purge all trashed archives (ignore retention)")
        cmd.Flags().BoolVar(&amp;flagForce, "force", false, "Skip confirmation prompts")
        cmd.Flags().BoolVar(&amp;flagDryRun, "dry-run", false, "Show actions without making changes")
        cmd.Flags().IntVar(&amp;flagWithin, "within-days", 0, "Only purge items purging within N days (0=all)")
        return cmd</span>
}

// parseYMD parses YYYY-MM-DD into time at midnight local
func parseYMD(s string) (time.Time, error) <span class="cov8" title="1">{
        parts := strings.Split(s, "-")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("expected YYYY-MM-DD")
        }</span>
        <span class="cov8" title="1">y, m, d := parts[0], parts[1], parts[2]
        year, err := strconv.Atoi(y)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">month, err := strconv.Atoi(m)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">day, err := strconv.Atoi(d)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.Local), nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

func UploadCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "upload &lt;archive&gt;",
                Short: "Upload archive to TrueNAS",
                Long:  `Upload an archive to TrueNAS storage via SSH/SFTP.`,
                Args:  cobra.ExactArgs(1),
                RunE:  runUpload,
        }

        // Add flags
        cmd.Flags().String("path", "", "Remote path on TrueNAS")
        cmd.Flags().String("storage", "truenas", "Storage backend to use")
        cmd.Flags().Bool("skip-existing", true, "Skip if file already exists")

        return cmd
}</span>

func runUpload(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        archivePath := args[0]
        remotePath, _ := cmd.Flags().GetString("path")

        out := cmd.OutOrStdout()
        fmt.Fprintf(out, "Uploading %s to TrueNAS...\n", archivePath)
        if remotePath != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(out, "Remote path: %s\n", remotePath)
        }</span>

        // TODO: Implement TrueNAS upload
        <span class="cov0" title="0">fmt.Fprintf(out, "\n⚠️  Upload functionality coming soon!\n")
        fmt.Fprintf(out, "This will upload to TrueNAS via SSH/SFTP.\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package archive

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

// Archive represents a 7z archive with metadata
type Archive struct {
        Path         string
        Size         int64
        FileCount    int
        Created      time.Time
        Checksum     string
        Metadata     *Metadata
        OriginalSize int64
        Profile      CompressionProfile // Profile used for compression
}

// Metadata contains archive metadata
type Metadata struct {
        Files       []FileInfo
        Created     time.Time
        Compression string
        Notes       string
}

// FileInfo represents a file in the archive
type FileInfo struct {
        Path     string
        Size     int64
        Modified time.Time
        Mode     os.FileMode
}

// Manager handles archive operations
type Manager struct {
        // Can add configuration here
}

// NewManager creates a new archive manager
func NewManager() *Manager <span class="cov0" title="0">{
        return &amp;Manager{}
}</span>

// CreateOptions contains options for creating archives
type CreateOptions struct {
        Source           string
        Output           string
        CompressionLevel int
        Threads          int
        Exclude          []string
        Profile          string // Compression profile name
        SmartCompression bool   // Auto-detect optimal profile (deprecated - now default)
        Comprehensive    bool   // Create log and checksums
        Force            bool   // Overwrite existing files
        // Config-driven thresholds (percent values); 0 means use defaults
        MediaThreshold int
        DocsThreshold  int
}

// Create creates a new archive
func (m *Manager) Create(ctx context.Context, opts CreateOptions) (*Archive, error) <span class="cov0" title="0">{
        var profile CompressionProfile
        var err error

        // Always analyze content to educate the user, with config-driven thresholds
        mediaTh := opts.MediaThreshold
        docsTh := opts.DocsThreshold
        if mediaTh &lt;= 0 </span><span class="cov0" title="0">{
                mediaTh = 70
        }</span>
        <span class="cov0" title="0">if docsTh &lt;= 0 </span><span class="cov0" title="0">{
                docsTh = 60
        }</span>
        <span class="cov0" title="0">stats, recommended, analyzeErr := AnalyzeContentWithThresholds(opts.Source, mediaTh, docsTh)
        if analyzeErr != nil </span><span class="cov0" title="0">{
                // Don't fail on analysis error, just skip the educational output
                fmt.Printf("⚠️  Content analysis unavailable: %v\n\n", analyzeErr)
        }</span> else<span class="cov0" title="0"> {
                // Show content breakdown to educate user
                fmt.Printf("📊 Content Analysis:\n")
                fmt.Printf("  Total: %d files, %.1f MB\n", stats.TotalFiles, float64(stats.TotalBytes)/(1024*1024))
                if stats.MediaFiles &gt; 0 </span><span class="cov0" title="0">{
                        mediaPercent := float64(stats.MediaBytes) / float64(stats.TotalBytes) * 100
                        fmt.Printf("  Media: %d files (%.1f%%), %.1f MB\n", stats.MediaFiles, mediaPercent, float64(stats.MediaBytes)/(1024*1024))
                }</span>
                <span class="cov0" title="0">if stats.DocumentFiles &gt; 0 </span><span class="cov0" title="0">{
                        docPercent := float64(stats.DocumentBytes) / float64(stats.TotalBytes) * 100
                        fmt.Printf("  Documents: %d files (%.1f%%), %.1f MB\n", stats.DocumentFiles, docPercent, float64(stats.DocumentBytes)/(1024*1024))
                }</span>
                <span class="cov0" title="0">if stats.CompressedFiles &gt; 0 </span><span class="cov0" title="0">{
                        compPercent := float64(stats.CompressedBytes) / float64(stats.TotalBytes) * 100
                        fmt.Printf("  Compressed: %d files (%.1f%%), %.1f MB\n", stats.CompressedFiles, compPercent, float64(stats.CompressedBytes)/(1024*1024))
                }</span>
                <span class="cov0" title="0">if stats.OtherFiles &gt; 0 </span><span class="cov0" title="0">{
                        otherPercent := float64(stats.OtherBytes) / float64(stats.TotalBytes) * 100
                        fmt.Printf("  Other: %d files (%.1f%%), %.1f MB\n", stats.OtherFiles, otherPercent, float64(stats.OtherBytes)/(1024*1024))
                }</span>
                <span class="cov0" title="0">fmt.Printf("\n")</span>
        }

        // Determine which compression profile to use
        <span class="cov0" title="0">if opts.Profile != "" </span><span class="cov0" title="0">{
                // Use specified profile
                var exists bool
                profile, exists = GetProfile(opts.Profile)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown compression profile: %s", opts.Profile)
                }</span>
                <span class="cov0" title="0">fmt.Printf("🎯 Using Profile: %s\n", profile.Name)
                fmt.Printf("   %s\n", profile.Description)
                fmt.Printf("   Settings: Level %d, Dictionary %s, Fast bytes %d\n\n",
                        profile.Level, profile.DictionarySize, profile.FastBytes)</span>
        } else<span class="cov0" title="0"> if opts.CompressionLevel &gt; 0 </span><span class="cov0" title="0">{
                // Manual compression level specified - use traditional mode
                profile = CompressionProfile{
                        Level:          opts.CompressionLevel,
                        DictionarySize: "32m",
                        FastBytes:      64,
                        SolidMode:      true,
                        Algorithm:      "lzma2",
                }

                // Educational message about available optimizations
                if analyzeErr == nil </span><span class="cov0" title="0">{
                        fmt.Printf("💡 Optimization Tip: Based on your content, --profile %s might be faster\n",
                                strings.ToLower(recommended.Name))
                        fmt.Printf("   Run '7zarch-go profiles' to see all available profiles\n\n")
                }</span>
        } else<span class="cov0" title="0"> {
                // Smart compression by default - use recommended profile
                if analyzeErr != nil </span><span class="cov0" title="0">{
                        // Fallback to balanced if analysis failed
                        profile, _ = GetProfile("balanced")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("🎯 Using Smart Profile: %s\n", recommended.Name)
                        fmt.Printf("   %s\n", recommended.Description)
                        fmt.Printf("   Settings: Level %d, Dictionary %s, Fast bytes %d\n\n",
                                recommended.Level, recommended.DictionarySize, recommended.FastBytes)

                        profile = recommended
                }</span>
        }

        // Build 7z command
        <span class="cov0" title="0">args := []string{"a"}

        // Add output file
        args = append(args, opts.Output)

        // Force overwrite without prompting
        args = append(args, "-y")

        // Apply compression profile parameters
        args = append(args, "-t7z")
        args = append(args, fmt.Sprintf("-m0=%s", profile.Algorithm))
        args = append(args, fmt.Sprintf("-mx=%d", profile.Level))
        args = append(args, fmt.Sprintf("-mfb=%d", profile.FastBytes))
        args = append(args, fmt.Sprintf("-md=%s", profile.DictionarySize))
        if profile.SolidMode </span><span class="cov0" title="0">{
                args = append(args, "-ms=on")
        }</span> else<span class="cov0" title="0"> {
                args = append(args, "-ms=off")
        }</span>

        // Add thread count if specified
        <span class="cov0" title="0">if opts.Threads &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, fmt.Sprintf("-mmt=%d", opts.Threads))
        }</span>

        // Add source
        <span class="cov0" title="0">args = append(args, opts.Source)

        // Add excludes
        for _, exclude := range opts.Exclude </span><span class="cov0" title="0">{
                args = append(args, fmt.Sprintf("-x!%s", exclude))
        }</span>

        // Execute 7z command
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "7z", args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("7z failed: %w\nOutput: %s", err, string(output))
        }</span>

        // Get archive info
        <span class="cov0" title="0">info, err := os.Stat(opts.Output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat archive: %w", err)
        }</span>

        // Calculate checksum
        <span class="cov0" title="0">checksum, err := calculateFileChecksum(opts.Output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>

        // Get file count from output
        <span class="cov0" title="0">fileCount := extractFileCount(string(output))

        archive := &amp;Archive{
                Path:      opts.Output,
                Size:      info.Size(),
                FileCount: fileCount,
                Created:   time.Now(),
                Checksum:  checksum,
                Profile:   profile,
        }

        // Use analysis totals as original size to avoid a second directory walk
        if analyzeErr == nil &amp;&amp; stats != nil </span><span class="cov0" title="0">{
                archive.OriginalSize = stats.TotalBytes
        }</span>

        // Handle comprehensive mode (create log and checksums)
        <span class="cov0" title="0">if opts.Comprehensive </span><span class="cov0" title="0">{
                // Create log file
                logPath := archive.Path + ".log"
                if err := CreateLogFile(logPath, archive, opts.Source); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Failed to create log: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Log created: %s\n", logPath)
                }</span>

                // Create checksum file
                <span class="cov0" title="0">checksumPath := archive.Path + ".sha256"
                if err := CreateChecksumFile(checksumPath, archive); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Failed to create checksum: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Checksum created: %s\n", checksumPath)
                }</span>
        }

        <span class="cov0" title="0">return archive, nil</span>
}

// TestResult contains the results of archive testing
type TestResult struct {
        Passed        bool
        ChecksumValid bool
        MetadataValid bool
        FilesVerified int
        Errors        []string
        Duration      time.Duration
}

// Test verifies archive integrity
func (m *Manager) Test(ctx context.Context, archivePath string) (*TestResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        result := &amp;TestResult{
                Passed: true,
                Errors: []string{},
        }

        // Test 1: Archive structure integrity
        if err := m.testArchiveIntegrity(ctx, archivePath); err != nil </span><span class="cov0" title="0">{
                result.Passed = false
                result.Errors = append(result.Errors, fmt.Sprintf("Archive integrity: %v", err))
        }</span>

        // Test 2: Checksum verification (if .sha256 exists)
        <span class="cov0" title="0">checksumFile := archivePath + ".sha256"
        if _, err := os.Stat(checksumFile); err == nil </span><span class="cov0" title="0">{
                if err := m.verifyChecksum(archivePath, checksumFile); err != nil </span><span class="cov0" title="0">{
                        result.Passed = false
                        result.ChecksumValid = false
                        result.Errors = append(result.Errors, fmt.Sprintf("Checksum: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.ChecksumValid = true
                }</span>
        }

        // Test 3: Metadata validation (if .log exists)
        <span class="cov0" title="0">metadataFile := archivePath + ".log"
        if _, err := os.Stat(metadataFile); err == nil </span><span class="cov0" title="0">{
                if err := m.validateMetadata(ctx, archivePath, metadataFile); err != nil </span><span class="cov0" title="0">{
                        result.Passed = false
                        result.MetadataValid = false
                        result.Errors = append(result.Errors, fmt.Sprintf("Metadata: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.MetadataValid = true
                }</span>
        }

        // Test 4: List files (quick extraction test)
        <span class="cov0" title="0">fileCount, err := m.listArchiveFiles(ctx, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                result.Passed = false
                result.Errors = append(result.Errors, fmt.Sprintf("File listing: %v", err))
        }</span> else<span class="cov0" title="0"> {
                result.FilesVerified = fileCount
        }</span>

        <span class="cov0" title="0">result.Duration = time.Since(startTime)
        return result, nil</span>
}

// testArchiveIntegrity runs 7z test command and relies on exit code for success
func (m *Manager) testArchiveIntegrity(ctx context.Context, archivePath string) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "7z", "t", archivePath)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integrity test failed: %w\nOutput: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// countPathsInSlt counts file entries by scanning for "Path = " lines in -slt output
func countPathsInSlt(output string) int <span class="cov8" title="1">{
        lines := strings.Split(output, "\n")
        count := 0
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.TrimSpace(line), "Path = ") </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// verifyChecksum compares archive checksum with stored value
func (m *Manager) verifyChecksum(archivePath, checksumFile string) error <span class="cov0" title="0">{
        // Read expected checksum
        // #nosec G304: checksumFile is created by our toolchain in managed path
        data, err := os.ReadFile(checksumFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read checksum file: %w", err)
        }</span>

        // Parse checksum (format: "hash  filename")
        <span class="cov0" title="0">parts := strings.Fields(string(data))
        if len(parts) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid checksum file format")
        }</span>
        <span class="cov0" title="0">expectedChecksum := parts[0]

        // Calculate actual checksum
        actualChecksum, err := calculateFileChecksum(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>

        // Compare
        <span class="cov0" title="0">if actualChecksum != expectedChecksum </span><span class="cov0" title="0">{
                return fmt.Errorf("checksum mismatch: expected %s, got %s", expectedChecksum, actualChecksum)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateMetadata checks metadata consistency
func (m *Manager) validateMetadata(ctx context.Context, archivePath, metadataFile string) error <span class="cov0" title="0">{
        // This would parse the .log file and validate against archive contents
        // For now, just check if we can read it
        // #nosec G304: metadataFile path is generated by our toolchain
        _, err := os.ReadFile(metadataFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read metadata: %w", err)
        }</span>

        // TODO: Parse and validate metadata against actual archive contents

        <span class="cov0" title="0">return nil</span>
}

// listArchiveFiles counts files in archive using structured listing (-slt)
func (m *Manager) listArchiveFiles(ctx context.Context, archivePath string) (int, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "7z", "l", "-slt", "-scsUTF-8", archivePath)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to list files: %w\nOutput: %s", err, string(output))
        }</span>

        // In -slt output, each file section starts with "Path = ...". Count these.
        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        fileCount := 0
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.TrimSpace(line), "Path = ") </span><span class="cov0" title="0">{
                        fileCount++
                }</span>
        }
        <span class="cov0" title="0">return fileCount, nil</span>
}

// Helper functions

func calculateFileChecksum(path string) (string, error) <span class="cov0" title="0">{
        // #nosec G304: path comes from validated CLI argument or managed registry
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

func calculateDirectorySize(path string) (int64, error) <span class="cov0" title="0">{
        var size int64
        err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        size += info.Size()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return size, err</span>
}

func extractFileCount(output string) int <span class="cov0" title="0">{
        // Try to parse totals from standard output summary first
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                l := strings.TrimSpace(line)
                // Example patterns observed:
                // "Files: 15"
                // "15 files, 2048576 bytes"
                if strings.HasPrefix(l, "Files:") </span><span class="cov0" title="0">{
                        var label string
                        var count int
                        if _, err := fmt.Sscanf(l, "%s %d", &amp;label, &amp;count); err == nil </span><span class="cov0" title="0">{
                                return count
                        }</span>
                }
                <span class="cov0" title="0">if strings.Contains(l, " files") </span><span class="cov0" title="0">{
                        parts := strings.Fields(l)
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                var count int
                                if _, err := fmt.Sscanf(parts[0], "%d", &amp;count); err == nil </span><span class="cov0" title="0">{
                                        return count
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return 0</span>
}

// CreateLogFile creates a metadata log file for the archive
func CreateLogFile(logPath string, archive *Archive, sourcePath string) error <span class="cov0" title="0">{
        // Use restrictive permissions for log file
        // #nosec G304: logPath is created by our tool in a managed directory (not user-controlled)
        file, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Write metadata
        fmt.Fprintf(file, "Archive: %s\n", archive.Path)
        fmt.Fprintf(file, "Created: %s\n", archive.Created.Format(time.RFC3339))
        fmt.Fprintf(file, "Source: %s\n", sourcePath)
        fmt.Fprintf(file, "Size: %d bytes\n", archive.Size)
        fmt.Fprintf(file, "Files: %d\n", archive.FileCount)
        fmt.Fprintf(file, "Checksum: %s\n", archive.Checksum)

        if archive.OriginalSize &gt; 0 </span><span class="cov0" title="0">{
                ratio := float64(archive.Size) / float64(archive.OriginalSize) * 100
                fmt.Fprintf(file, "Compression: %.1f%%\n", ratio)
        }</span>

        // TODO: Add file listing with details

        <span class="cov0" title="0">return nil</span>
}

// CreateChecksumFile creates a SHA256 checksum file
func CreateChecksumFile(checksumPath string, archive *Archive) error <span class="cov0" title="0">{
        // Use restrictive permissions for checksum file
        // #nosec G304: checksumPath is created by our tool in a managed directory (not user-controlled)
        file, err := os.OpenFile(checksumPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Write checksum in standard format: "hash  filename"
        fmt.Fprintf(file, "%s  %s\n", archive.Checksum, filepath.Base(archive.Path))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package archive

import (
        "os"
        "path/filepath"
        "strings"
)

// CompressionProfile defines optimal 7z parameters for different content types
type CompressionProfile struct {
        Name           string
        Description    string
        Level          int    // -mx parameter
        DictionarySize string // -md parameter
        FastBytes      int    // -mfb parameter
        SolidMode      bool   // -ms parameter
        Algorithm      string // compression algorithm
}

// Predefined compression profiles
var profiles = map[string]CompressionProfile{
        "media": {
                Name:           "Media",
                Description:    "Optimized for video, audio, and images (faster, good ratio for pre-compressed data)",
                Level:          3,
                DictionarySize: "16m",
                FastBytes:      32,
                SolidMode:      false,
                Algorithm:      "lzma2",
        },
        "documents": {
                Name:           "Documents",
                Description:    "Optimized for text, code, and office files (maximum compression)",
                Level:          9,
                DictionarySize: "64m",
                FastBytes:      273,
                SolidMode:      true,
                Algorithm:      "lzma2",
        },
        "balanced": {
                Name:           "Balanced",
                Description:    "Good compression with reasonable speed for mixed content",
                Level:          7,
                DictionarySize: "32m",
                FastBytes:      64,
                SolidMode:      true,
                Algorithm:      "lzma2",
        },
}

// ContentStats holds analysis results of directory contents
type ContentStats struct {
        TotalBytes      int64
        TotalFiles      int
        MediaBytes      int64
        MediaFiles      int
        DocumentBytes   int64
        DocumentFiles   int
        CompressedBytes int64
        CompressedFiles int
        OtherBytes      int64
        OtherFiles      int
}

// GetProfile returns a compression profile by name
func GetProfile(name string) (CompressionProfile, bool) <span class="cov0" title="0">{
        profile, exists := profiles[name]
        return profile, exists
}</span>

// ListProfiles returns all available profiles
func ListProfiles() []CompressionProfile <span class="cov0" title="0">{
        result := make([]CompressionProfile, 0, len(profiles))
        for _, profile := range profiles </span><span class="cov0" title="0">{
                result = append(result, profile)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AnalyzeContent examines directory contents and recommends optimal compression profile
func AnalyzeContent(sourcePath string) (*ContentStats, CompressionProfile, error) <span class="cov0" title="0">{
        return AnalyzeContentWithThresholds(sourcePath, 70, 60)
}</span>

// AnalyzeContentWithThresholds allows custom thresholds for media/docs percentages
func AnalyzeContentWithThresholds(sourcePath string, mediaThreshold int, docsThreshold int) (*ContentStats, CompressionProfile, error) <span class="cov0" title="0">{
        stats := &amp;ContentStats{}

        err := filepath.Walk(sourcePath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(path))
                size := info.Size()
                stats.TotalBytes += size
                stats.TotalFiles++
                switch </span>{
                case isMediaFile(ext):<span class="cov0" title="0">
                        stats.MediaBytes += size
                        stats.MediaFiles++</span>
                case isDocumentFile(ext):<span class="cov0" title="0">
                        stats.DocumentBytes += size
                        stats.DocumentFiles++</span>
                case isCompressedFile(ext):<span class="cov0" title="0">
                        stats.CompressedBytes += size
                        stats.CompressedFiles++</span>
                default:<span class="cov0" title="0">
                        stats.OtherBytes += size
                        stats.OtherFiles++</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, CompressionProfile{}, err
        }</span>
        // Recommend profile based on content analysis and custom thresholds
        <span class="cov0" title="0">recommended := recommendProfileWithThresholds(stats, mediaThreshold, docsThreshold)
        return stats, recommended, nil</span>
}

// isMediaFile checks if file extension indicates media content
func isMediaFile(ext string) bool <span class="cov0" title="0">{
        mediaExts := map[string]bool{
                // Video
                ".mp4": true, ".avi": true, ".mkv": true, ".mov": true, ".wmv": true,
                ".flv": true, ".webm": true, ".m4v": true, ".3gp": true, ".mpg": true,
                ".mpeg": true, ".ts": true, ".mts": true,

                // Audio
                ".mp3": true, ".wav": true, ".flac": true, ".aac": true, ".ogg": true,
                ".wma": true, ".m4a": true, ".opus": true, ".aiff": true,

                // Images
                ".jpg": true, ".jpeg": true, ".png": true, ".gif": true, ".bmp": true,
                ".tiff": true, ".webp": true, ".svg": true, ".ico": true, ".raw": true,
                ".cr2": true, ".nef": true, ".arw": true, ".dng": true,
        }
        return mediaExts[ext]
}</span>

// isDocumentFile checks if file extension indicates document/text content
func isDocumentFile(ext string) bool <span class="cov0" title="0">{
        docExts := map[string]bool{
                // Text/Code
                ".txt": true, ".md": true, ".rst": true, ".rtf": true,
                ".go": true, ".py": true, ".js": true, ".ts": true, ".java": true,
                ".c": true, ".cpp": true, ".h": true, ".hpp": true, ".cs": true,
                ".php": true, ".rb": true, ".rs": true, ".swift": true, ".kt": true,
                ".html": true, ".css": true, ".scss": true, ".less": true,
                ".xml": true, ".json": true, ".yaml": true, ".yml": true, ".toml": true,
                ".sh": true, ".bat": true, ".ps1": true, ".sql": true,

                // Office Documents
                ".doc": true, ".docx": true, ".xls": true, ".xlsx": true,
                ".ppt": true, ".pptx": true, ".odt": true, ".ods": true, ".odp": true,
                ".pdf": true, ".tex": true, ".epub": true, ".mobi": true,

                // Configuration
                ".conf": true, ".cfg": true, ".ini": true, ".properties": true,
                ".env": true, ".gitignore": true, ".dockerignore": true,
        }
        return docExts[ext]
}</span>

// isCompressedFile checks if file is already compressed
func isCompressedFile(ext string) bool <span class="cov0" title="0">{
        compressedExts := map[string]bool{
                ".zip": true, ".rar": true, ".7z": true, ".tar": true, ".gz": true,
                ".bz2": true, ".xz": true, ".lz": true, ".lzma": true, ".zst": true,
                ".jar": true, ".war": true, ".ear": true, ".apk": true, ".ipa": true,
        }
        return compressedExts[ext]
}</span>

// recommendProfile analyzes content statistics and recommends best profile
func recommendProfile(stats *ContentStats) CompressionProfile <span class="cov0" title="0">{
        return recommendProfileWithThresholds(stats, 70, 60)
}</span>

// recommendProfileWithThresholds uses configurable thresholds (percent values)
func recommendProfileWithThresholds(stats *ContentStats, mediaThreshold int, docsThreshold int) CompressionProfile <span class="cov8" title="1">{
        if stats.TotalBytes == 0 </span><span class="cov0" title="0">{
                return profiles["balanced"] // Default fallback
        }</span>
        <span class="cov8" title="1">mediaPercent := float64(stats.MediaBytes) / float64(stats.TotalBytes) * 100
        docPercent := float64(stats.DocumentBytes) / float64(stats.TotalBytes) * 100
        compressedPercent := float64(stats.CompressedBytes) / float64(stats.TotalBytes) * 100
        if mediaPercent &gt;= float64(mediaThreshold) </span><span class="cov8" title="1">{
                return profiles["media"]
        }</span>
        <span class="cov8" title="1">if docPercent &gt;= float64(docsThreshold) </span><span class="cov8" title="1">{
                return profiles["documents"]
        }</span>
        <span class="cov8" title="1">if compressedPercent &gt;= 50.0 </span><span class="cov8" title="1">{
                return profiles["media"] // Use media settings for already compressed data
        }</span>
        <span class="cov8" title="1">return profiles["balanced"]</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmdutil

import (
        "fmt"

        "github.com/adamstac/7zarch-go/internal/config"
        errs "github.com/adamstac/7zarch-go/internal/errors"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// InitStorageManager is a helper that loads config and creates storage manager
// Returns config, storage manager, and cleanup function
func InitStorageManager() (*config.Config, *storage.Manager, func(), error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">mgr, err := storage.NewManager(cfg.Storage.ManagedPath)
        if err != nil </span><span class="cov0" title="0">{
                return cfg, nil, nil, fmt.Errorf("failed to initialize storage manager: %w", err)
        }</span>

        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{
                mgr.Close()
        }</span>

        <span class="cov0" title="0">return cfg, mgr, cleanup, nil</span>
}

// LoadConfigOrDefault attempts to load config but falls back to defaults
// Used in create command and similar cases where config errors are non-fatal
func LoadConfigOrDefault() *config.Config <span class="cov0" title="0">{
        if cfg, err := config.Load(); err == nil </span><span class="cov0" title="0">{
                return cfg
        }</span>
        <span class="cov0" title="0">return config.DefaultConfig()</span>
}

// HandleResolverError converts storage resolver errors to consistent user-friendly errors
func HandleResolverError(err error, id string) error <span class="cov0" title="0">{
        if _, ok := err.(*storage.AmbiguousIDError); ok </span><span class="cov0" title="0">{
                return &amp;errs.ValidationError{
                        Field:   "archive ID",
                        Value:   id,
                        Message: "matches multiple archives. Use a longer prefix or full UID",
                }
        }</span>
        <span class="cov0" title="0">if _, ok := err.(*storage.ArchiveNotFoundError); ok </span><span class="cov0" title="0">{
                return errs.NewArchiveNotFound(id)
        }</span>
        <span class="cov0" title="0">return err</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config represents the application configuration
type Config struct {
        Compression CompressionConfig        `yaml:"compression"`
        Defaults    DefaultsConfig           `yaml:"defaults"`
        UI          UIConfig                 `yaml:"ui"`
        Profiles    map[string]CustomProfile `yaml:"profiles"`
        TrueNAS     TrueNASConfig            `yaml:"truenas"`
        Presets     map[string]PresetConfig  `yaml:"presets"`
        Storage     StorageConfig            `yaml:"storage"`
}

type CompressionConfig struct {
        SmartDefault   bool `yaml:"smart_default"`
        Level          int  `yaml:"level"`
        MediaThreshold int  `yaml:"media_threshold"`
        DocsThreshold  int  `yaml:"docs_threshold"`
}

type DefaultsConfig struct {
        Create CreateDefaults `yaml:"create"`
        Test   TestDefaults   `yaml:"test"`
}

type CreateDefaults struct {
        Comprehensive bool `yaml:"comprehensive"`
        Force         bool `yaml:"force"`
        Threads       int  `yaml:"threads"`
}

type TestDefaults struct {
        Concurrent int  `yaml:"concurrent"`
        Verbose    bool `yaml:"verbose"`
}

type UIConfig struct {
        ShowAnalysis  bool   `yaml:"show_analysis"`
        ShowTips      bool   `yaml:"show_tips"`
        ProgressStyle string `yaml:"progress_style"`
        Emojis        bool   `yaml:"emojis"`
}

type CustomProfile struct {
        Name        string `yaml:"name"`
        Description string `yaml:"description"`
        Level       int    `yaml:"level"`
        Dictionary  string `yaml:"dictionary"`
        FastBytes   int    `yaml:"fast_bytes"`
        SolidMode   bool   `yaml:"solid_mode"`
        Algorithm   string `yaml:"algorithm"`
}

type TrueNASConfig struct {
        DefaultHost string `yaml:"default_host"`
        UploadPath  string `yaml:"upload_path"`
        VerifySSL   bool   `yaml:"verify_ssl"`
        Timeout     int    `yaml:"timeout"`
}

type PresetConfig struct {
        Profile       string   `yaml:"profile"`
        Comprehensive bool     `yaml:"comprehensive"`
        Force         bool     `yaml:"force"`
        Output        string   `yaml:"output"`
        Threads       int      `yaml:"threads"`
        Exclude       []string `yaml:"exclude"`
}

type StorageConfig struct {
        ManagedPath       string `yaml:"managed_path"`
        UseManagedDefault bool   `yaml:"use_managed_default"`
        RegisterExternal  bool   `yaml:"register_external"`
        AutoOrganize      string `yaml:"auto_organize"` // flat, by_date, by_type
        RetentionDays     int    `yaml:"retention_days"`
}

// DefaultConfig returns the default configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Compression: CompressionConfig{
                        SmartDefault:   true,
                        Level:          9,
                        MediaThreshold: 70,
                        DocsThreshold:  60,
                },
                Defaults: DefaultsConfig{
                        Create: CreateDefaults{
                                Comprehensive: false,
                                Force:         false,
                                Threads:       0,
                        },
                        Test: TestDefaults{
                                Concurrent: 5,
                                Verbose:    false,
                        },
                },
                UI: UIConfig{
                        ShowAnalysis:  true,
                        ShowTips:      true,
                        ProgressStyle: "spinner",
                        Emojis:        true,
                },
                Profiles: map[string]CustomProfile{},
                TrueNAS: TrueNASConfig{
                        DefaultHost: "truenas-homelab.local",
                        UploadPath:  "/mnt/tank/archives",
                        VerifySSL:   true,
                        Timeout:     300,
                },
                Storage: StorageConfig{
                        ManagedPath:       "~/.7zarch-go",
                        UseManagedDefault: true,
                        RegisterExternal:  true,
                        AutoOrganize:      "flat",
                        RetentionDays:     30,
                },
                Presets: map[string]PresetConfig{
                        "podcast": {
                                Profile:       "media",
                                Comprehensive: true,
                                Output:        "~/Archives/Podcasts",
                        },
                        "backup": {
                                Profile:       "balanced",
                                Comprehensive: true,
                                Force:         true,
                        },
                        "source_code": {
                                Profile:       "documents",
                                Comprehensive: true,
                                Exclude:       []string{"node_modules", ".git", "target", "build"},
                        },
                },
        }
}</span>

// Load loads configuration from ~/.7zarch-go-config
func Load() (*Config, error) <span class="cov0" title="0">{
        config := DefaultConfig()

        // Get config file path
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return config, nil // Return defaults if we can't find home
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(home, ".7zarch-go-config")

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return config, nil // Return defaults if config doesn't exist
        }</span>

        // Read config file
        // #nosec G304: configPath is constructed from $HOME and a fixed filename
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return config, nil // Return defaults on read error
        }</span>

        // Parse YAML
        <span class="cov0" title="0">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return config, nil // Return defaults on parse error
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// ConfigPath returns the path to the config file
func ConfigPath() (string, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(home, ".7zarch-go-config"), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package debug

import (
        "fmt"
        "runtime"
        "time"

        "github.com/dustin/go-humanize"
)

// Metrics holds performance information for debug output
type Metrics struct {
        StartTime    time.Time
        QueryTime    time.Duration
        RenderTime   time.Duration
        ResultCount  int
        DatabaseSize int64
        MemoryBefore uint64
        MemoryAfter  uint64
}

// NewMetrics creates a new metrics collector
func NewMetrics() *Metrics <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        return &amp;Metrics{
                StartTime:    time.Now(),
                MemoryBefore: m.Alloc,
        }
}</span>

// RecordQueryTime marks the query completion
func (m *Metrics) RecordQueryTime() <span class="cov0" title="0">{
        m.QueryTime = time.Since(m.StartTime)
}</span>

// RecordRenderTime marks the render completion
func (m *Metrics) RecordRenderTime() <span class="cov0" title="0">{
        m.RenderTime = time.Since(m.StartTime) - m.QueryTime
}</span>

// SetResultCount sets the number of results
func (m *Metrics) SetResultCount(count int) <span class="cov0" title="0">{
        m.ResultCount = count
}</span>

// SetDatabaseSize sets the database size
func (m *Metrics) SetDatabaseSize(size int64) <span class="cov0" title="0">{
        m.DatabaseSize = size
}</span>

// Finish collects final memory stats
func (m *Metrics) Finish() <span class="cov0" title="0">{
        var ms runtime.MemStats
        runtime.ReadMemStats(&amp;ms)
        m.MemoryAfter = ms.Alloc
}</span>

// String formats metrics for output
func (m *Metrics) String() string <span class="cov0" title="0">{
        m.Finish()
        memUsed := uint64(0)
        if m.MemoryAfter &gt; m.MemoryBefore </span><span class="cov0" title="0">{
                memUsed = m.MemoryAfter - m.MemoryBefore
        }</span>
        
        <span class="cov0" title="0">return fmt.Sprintf("DEBUG: Query: %v, Render: %v, Results: %d, DB: %s, Memory: %s",
                m.QueryTime.Round(time.Millisecond),
                m.RenderTime.Round(time.Millisecond),
                m.ResultCount,
                humanize.Bytes(uint64(m.DatabaseSize)),
                humanize.Bytes(memUsed))</span>
}

// Summary provides a multi-line debug summary
func (m *Metrics) Summary() string <span class="cov0" title="0">{
        m.Finish()
        memUsed := uint64(0)
        if m.MemoryAfter &gt; m.MemoryBefore </span><span class="cov0" title="0">{
                memUsed = m.MemoryAfter - m.MemoryBefore
        }</span>
        
        <span class="cov0" title="0">total := time.Since(m.StartTime)
        
        return fmt.Sprintf(`
Performance Metrics:
  Query Time:    %v
  Render Time:   %v
  Total Time:    %v
  Result Count:  %d
  Database Size: %s
  Memory Used:   %s`,
                m.QueryTime.Round(time.Millisecond),
                m.RenderTime.Round(time.Millisecond),
                total.Round(time.Millisecond),
                m.ResultCount,
                humanize.Bytes(uint64(m.DatabaseSize)),
                humanize.Bytes(memUsed))</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package display

import (
        "fmt"
        "os"
        "strings"

        "github.com/adamstac/7zarch-go/internal/storage"
        "golang.org/x/term"
)

// Mode represents a display mode type
type Mode string

const (
        ModeAuto      Mode = "auto"
        ModeTable     Mode = "table"
        ModeCompact   Mode = "compact"
        ModeCard      Mode = "card"
        ModeTree      Mode = "tree"
        ModeDashboard Mode = "dashboard"
)

// Options configures display behavior
type Options struct {
        Mode         Mode
        Details      bool
        Width        int
        ShowHeaders  bool
        Columns      []string
        GroupBy      string
        SortBy       []string
        ColorEnabled bool
}

// Context provides environmental information for display decisions
type Context struct {
        TerminalWidth int
        ArchiveCount  int
        FilterContext string
        OutputPiped   bool
}

// Display interface that all display modes must implement
type Display interface {
        Render(archives []*storage.Archive, opts Options) error
        Name() string
        MinWidth() int
}

// Manager handles display mode selection and rendering
type Manager struct {
        displays map[Mode]Display
        context  Context
}

// NewManager creates a new display manager
func NewManager() *Manager <span class="cov0" title="0">{
        return &amp;Manager{
                displays: make(map[Mode]Display),
                context:  detectContext(),
        }
}</span>

// Register adds a display mode to the manager
func (m *Manager) Register(mode Mode, display Display) <span class="cov0" title="0">{
        m.displays[mode] = display
}</span>

// Render displays archives using the specified or auto-detected mode
func (m *Manager) Render(archives []*storage.Archive, opts Options) error <span class="cov0" title="0">{
        mode := opts.Mode
        if mode == ModeAuto || mode == "" </span><span class="cov0" title="0">{
                mode = m.detectBestMode(opts)
        }</span>

        <span class="cov0" title="0">display, exists := m.displays[mode]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown display mode: %s", mode)
        }</span>

        // Update options with terminal width if not specified
        <span class="cov0" title="0">if opts.Width == 0 </span><span class="cov0" title="0">{
                opts.Width = m.context.TerminalWidth
        }</span>

        <span class="cov0" title="0">return display.Render(archives, opts)</span>
}

// detectBestMode determines the optimal display mode based on context
func (m *Manager) detectBestMode(opts Options) Mode <span class="cov0" title="0">{
        ctx := m.context

        // Piped output always uses compact
        if ctx.OutputPiped </span><span class="cov0" title="0">{
                return ModeCompact
        }</span>

        // Narrow terminals use compact
        <span class="cov0" title="0">if ctx.TerminalWidth &lt; 80 </span><span class="cov0" title="0">{
                return ModeCompact
        }</span>

        // Filter-specific defaults
        <span class="cov0" title="0">if ctx.FilterContext == "missing" </span><span class="cov0" title="0">{
                return ModeCompact
        }</span>

        // Large collections use table for scanning
        <span class="cov0" title="0">if ctx.ArchiveCount &gt; 50 </span><span class="cov0" title="0">{
                return ModeTable
        }</span>

        // Default to table for normal use
        <span class="cov0" title="0">return ModeTable</span>
}

// detectContext gathers environmental information
func detectContext() Context <span class="cov0" title="0">{
        ctx := Context{
                TerminalWidth: getTerminalWidth(),
                OutputPiped:   !isTerminal(),
        }
        return ctx
}</span>

// getTerminalWidth returns the current terminal width
func getTerminalWidth() int <span class="cov0" title="0">{
        if width, _, err := term.GetSize(int(os.Stdout.Fd())); err == nil </span><span class="cov0" title="0">{
                return width
        }</span>
        <span class="cov0" title="0">return 80</span> // default fallback
}

// isTerminal checks if output is going to a terminal
func isTerminal() bool <span class="cov0" title="0">{
        return term.IsTerminal(int(os.Stdout.Fd()))
}</span>

// Helper functions for formatting

// TruncateString truncates a string to maxLen with ellipsis
func TruncateString(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">if maxLen &lt;= 3 </span><span class="cov0" title="0">{
                return s[:maxLen]
        }</span>
        <span class="cov0" title="0">return s[:maxLen-1] + "…"</span>
}

// PadRight pads a string to the specified width
func PadRight(s string, width int) string <span class="cov0" title="0">{
        if len(s) &gt;= width </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s + strings.Repeat(" ", width-len(s))</span>
}

// FormatSize formats bytes as human-readable size
func FormatSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// FormatStatus formats archive status with consistent icons
func FormatStatus(status string, useIcons bool) string <span class="cov0" title="0">{
        if useIcons </span><span class="cov0" title="0">{
                switch status </span>{
                case "present":<span class="cov0" title="0">
                        return "✓"</span>
                case "missing":<span class="cov0" title="0">
                        return "?"</span>
                case "deleted":<span class="cov0" title="0">
                        return "X"</span>
                default:<span class="cov0" title="0">
                        return "?"</span>
                }
        } else<span class="cov0" title="0"> {
                switch status </span>{
                case "present":<span class="cov0" title="0">
                        return "OK"</span>
                case "missing":<span class="cov0" title="0">
                        return "MISS"</span>
                case "deleted":<span class="cov0" title="0">
                        return "DEL"</span>
                default:<span class="cov0" title="0">
                        return status</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package modes

import (
        "fmt"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// CardDisplay provides rich information display with visual hierarchy
type CardDisplay struct{}

// NewCardDisplay creates a new card display mode
func NewCardDisplay() *CardDisplay <span class="cov0" title="0">{
        return &amp;CardDisplay{}
}</span>

// Name returns the display mode name
func (cd *CardDisplay) Name() string <span class="cov0" title="0">{
        return "card"
}</span>

// MinWidth returns the minimum terminal width for this display
func (cd *CardDisplay) MinWidth() int <span class="cov0" title="0">{
        return 80
}</span>

// Render displays archives in card format
func (cd *CardDisplay) Render(archives []*storage.Archive, opts display.Options) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found\n")
                fmt.Printf("Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Group archives by status and location
        <span class="cov0" title="0">var managedActive, externalActive, deleted []*storage.Archive
        var missingCount int

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deleted = append(deleted, a)
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedActive = append(managedActive, a)
                }</span> else<span class="cov0" title="0"> {
                        externalActive = append(externalActive, a)
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        // Print summary header
        <span class="cov0" title="0">fmt.Printf("Archive Collection (%d archives found)\n", len(archives))
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n\n",
                len(managedActive)+len(externalActive), len(managedActive), len(externalActive), missingCount, len(deleted))

        // Print managed archives
        if len(managedActive) &gt; 0 </span><span class="cov0" title="0">{
                cd.printGroupHeader("MANAGED ARCHIVES", len(managedActive))
                for i, archive := range managedActive </span><span class="cov0" title="0">{
                        cd.printCard(archive, opts)
                        if i &lt; len(managedActive)-1 </span><span class="cov0" title="0">{
                                fmt.Println()
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Print external archives
        <span class="cov0" title="0">if len(externalActive) &gt; 0 </span><span class="cov0" title="0">{
                cd.printGroupHeader("EXTERNAL ARCHIVES", len(externalActive))
                for i, archive := range externalActive </span><span class="cov0" title="0">{
                        cd.printCard(archive, opts)
                        if i &lt; len(externalActive)-1 </span><span class="cov0" title="0">{
                                fmt.Println()
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Print deleted archives
        <span class="cov0" title="0">if len(deleted) &gt; 0 </span><span class="cov0" title="0">{
                cd.printGroupHeader("DELETED ARCHIVES", len(deleted))
                for i, archive := range deleted </span><span class="cov0" title="0">{
                        cd.printCard(archive, opts)
                        if i &lt; len(deleted)-1 </span><span class="cov0" title="0">{
                                fmt.Println()
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// printGroupHeader prints a section header
func (cd *CardDisplay) printGroupHeader(title string, count int) <span class="cov0" title="0">{
        fmt.Printf("%s\n", title)
}</span>

// printCard prints a single archive as a card
func (cd *CardDisplay) printCard(archive *storage.Archive, opts display.Options) <span class="cov0" title="0">{
        // Card border
        cardWidth := 70
        if opts.Width &gt; 0 &amp;&amp; opts.Width &lt; 80 </span><span class="cov0" title="0">{
                cardWidth = opts.Width - 10
        }</span>

        // Top border
        <span class="cov0" title="0">fmt.Printf("┌%s┐\n", strings.Repeat("─", cardWidth-2))

        // Archive name and ID
        name := archive.Name
        id := archive.UID
        if len(id) &gt; 12 </span><span class="cov0" title="0">{
                id = id[:12]
        }</span>

        // Calculate the full content: "name [id]"
        <span class="cov0" title="0">fullContent := fmt.Sprintf("%s [%s]", name, id)
        maxContentLen := cardWidth - 4 // 4 for "│ " + " │"

        // Truncate name if the full content is too long
        if len(fullContent) &gt; maxContentLen </span><span class="cov0" title="0">{
                availableNameLen := maxContentLen - len(id) - 3 // 3 for " [" + "]"
                if availableNameLen &gt; 3 </span><span class="cov0" title="0">{
                        name = name[:availableNameLen-3] + "..."
                }</span>
        }

        // Recalculate with potentially truncated name
        <span class="cov0" title="0">nameAndId := fmt.Sprintf("%s [%s]", name, id)
        titlePadding := cardWidth - 4 - len(nameAndId) // 4 for "│ " + " │"
        if titlePadding &lt; 0 </span><span class="cov0" title="0">{
                titlePadding = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("│ %s%s │\n", nameAndId, strings.Repeat(" ", titlePadding))

        // Separator
        fmt.Printf("│%s│\n", strings.Repeat("─", cardWidth-2))

        // Status and location
        status := cd.formatCardStatus(archive)
        location := "EXTERNAL"
        if archive.Managed </span><span class="cov0" title="0">{
                location = "MANAGED"
        }</span>

        // Calculate padding for this row
        <span class="cov0" title="0">statusPart := fmt.Sprintf("Status: %s", status)
        locationPart := fmt.Sprintf("Location: %s", location)
        contentLen1 := len(statusPart) + len(locationPart) + 4 // 4 for "│ " + " │"
        padding1 := cardWidth - contentLen1
        if padding1 &lt; 0 </span><span class="cov0" title="0">{
                padding1 = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("│ %s                           Location: %s\n", statusPart, location)

        // Size and profile
        size := display.FormatSize(archive.Size)
        profile := archive.Profile
        if profile == "" </span><span class="cov0" title="0">{
                profile = "default"
        }</span>

        // Calculate padding for this row
        <span class="cov0" title="0">sizePart := fmt.Sprintf("Size: %s", size)
        profilePart := fmt.Sprintf("Profile: %s", profile)
        contentLen2 := len(sizePart) + len(profilePart) + 4 // 4 for "│ " + " │"
        padding2 := cardWidth - contentLen2
        if padding2 &lt; 0 </span><span class="cov0" title="0">{
                padding2 = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("│ %s                                Profile: %s\n", sizePart, profile)

        // Created and age
        created := archive.Created.Format("2006-01-02 15:04:05")
        age := cd.formatCardAge(archive.Created)

        // Calculate padding for this row
        createdPart := fmt.Sprintf("Created: %s", created)
        agePart := fmt.Sprintf("Age: %s", age)
        contentLen3 := len(createdPart) + len(agePart) + 4 // 4 for "│ " + " │"
        padding3 := cardWidth - contentLen3
        if padding3 &lt; 0 </span><span class="cov0" title="0">{
                padding3 = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("│ %s                   Age: %s\n", createdPart, age)

        // Path
        path := archive.Path
        pathPart := fmt.Sprintf("Path: %s", path)

        // Truncate path if too long
        maxPathPartLen := cardWidth - 4 // 4 for "│ " + " │"
        if len(pathPart) &gt; maxPathPartLen </span><span class="cov0" title="0">{
                availablePathLen := maxPathPartLen - 6 // 6 for "Path: "
                if availablePathLen &gt; 10 </span><span class="cov0" title="0">{
                        truncatedPath := "..." + path[len(path)-(availablePathLen-3):]
                        pathPart = fmt.Sprintf("Path: %s", truncatedPath)
                }</span>
        }

        // Calculate padding for path row
        <span class="cov0" title="0">padding4 := cardWidth - 4 - len(pathPart) // 4 for "│ " + " │"
        if padding4 &lt; 0 </span><span class="cov0" title="0">{
                padding4 = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("│\n│ %s\n", pathPart)

        // Additional details if requested
        if opts.Details </span><span class="cov0" title="0">{
                fmt.Printf("│%s│\n", strings.Repeat("─", cardWidth-2))

                // Checksum (if available)
                if archive.Checksum != "" </span><span class="cov0" title="0">{
                        checksum := archive.Checksum
                        checksumPart := fmt.Sprintf("Checksum: %s", checksum)

                        // Truncate checksum if too long
                        maxChecksumPartLen := cardWidth - 4 // 4 for "│ " + " │"
                        if len(checksumPart) &gt; maxChecksumPartLen </span><span class="cov0" title="0">{
                                availableChecksumLen := maxChecksumPartLen - 10 // 10 for "Checksum: "
                                if availableChecksumLen &gt; 10 </span><span class="cov0" title="0">{
                                        truncatedChecksum := checksum[:availableChecksumLen-3] + "..."
                                        checksumPart = fmt.Sprintf("Checksum: %s", truncatedChecksum)
                                }</span>
                        }

                        // Calculate padding for checksum row
                        <span class="cov0" title="0">padding5 := cardWidth - 4 - len(checksumPart) // 4 for "│ " + " │"
                        if padding5 &lt; 0 </span><span class="cov0" title="0">{
                                padding5 = 0
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("│ %s%s │\n", checksumPart, strings.Repeat(" ", padding5))</span>
                }

                // Additional metadata for deleted archives
                <span class="cov0" title="0">if archive.Status == "deleted" &amp;&amp; archive.DeletedAt != nil </span><span class="cov0" title="0">{
                        deletedTime := archive.DeletedAt.Format("2006-01-02 15:04:05")
                        deletedPart := fmt.Sprintf("Deleted: %s", deletedTime)

                        // Calculate padding for deleted row
                        padding6 := cardWidth - 4 - len(deletedPart) // 4 for "│ " + " │"
                        if padding6 &lt; 0 </span><span class="cov0" title="0">{
                                padding6 = 0
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("│ %s%s │\n", deletedPart, strings.Repeat(" ", padding6))

                        // Days until auto-purge (assuming 7 day retention)
                        purgeDate := archive.DeletedAt.AddDate(0, 0, 7)
                        daysLeft := int(time.Until(purgeDate).Hours() / 24)
                        var purgePart string
                        if daysLeft &gt; 0 </span><span class="cov0" title="0">{
                                purgePart = fmt.Sprintf("Auto-purge in: %d days", daysLeft)
                        }</span> else<span class="cov0" title="0"> {
                                purgePart = "Auto-purge: overdue"
                        }</span>

                        // Calculate padding for purge row
                        <span class="cov0" title="0">padding7 := cardWidth - 4 - len(purgePart) // 4 for "│ " + " │"
                        if padding7 &lt; 0 </span><span class="cov0" title="0">{
                                padding7 = 0
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("│ %s%s │\n", purgePart, strings.Repeat(" ", padding7))</span>
                }

                // Original path for deleted archives
                <span class="cov0" title="0">if archive.OriginalPath != "" &amp;&amp; archive.OriginalPath != archive.Path </span><span class="cov0" title="0">{
                        origPath := archive.OriginalPath
                        originalPart := fmt.Sprintf("Original: %s", origPath)

                        // Truncate original path if too long
                        maxOriginalPartLen := cardWidth - 4 // 4 for "│ " + " │"
                        if len(originalPart) &gt; maxOriginalPartLen </span><span class="cov0" title="0">{
                                availableOrigPathLen := maxOriginalPartLen - 10 // 10 for "Original: "
                                if availableOrigPathLen &gt; 10 </span><span class="cov0" title="0">{
                                        truncatedOrigPath := "..." + origPath[len(origPath)-(availableOrigPathLen-3):]
                                        originalPart = fmt.Sprintf("Original: %s", truncatedOrigPath)
                                }</span>
                        }

                        // Calculate padding for original path row
                        <span class="cov0" title="0">padding8 := cardWidth - 4 - len(originalPart) // 4 for "│ " + " │"
                        if padding8 &lt; 0 </span><span class="cov0" title="0">{
                                padding8 = 0
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("│ %s%s │\n", originalPart, strings.Repeat(" ", padding8))</span>
                }
        }

        // Bottom border
        <span class="cov0" title="0">fmt.Printf("└%s│\n", strings.Repeat("─", cardWidth-2))</span>
}

// formatCardStatus returns a formatted status for cards
func (cd *CardDisplay) formatCardStatus(archive *storage.Archive) string <span class="cov0" title="0">{
        icon := display.FormatStatus(archive.Status, true)
        text := display.FormatStatus(archive.Status, false)
        return fmt.Sprintf("%s %s", icon, text)
}</span>

// formatCardAge formats duration since creation for cards
func (cd *CardDisplay) formatCardAge(created time.Time) string <span class="cov0" title="0">{
        age := time.Since(created)

        if age &lt; time.Hour </span><span class="cov0" title="0">{
                mins := int(age.Minutes())
                return fmt.Sprintf("%d minutes ago", mins)
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(age.Hours())
                return fmt.Sprintf("%d hours ago", hours)
        }</span>
        <span class="cov0" title="0">if age &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                days := int(age.Hours() / 24)
                return fmt.Sprintf("%d days ago", days)
        }</span>
        <span class="cov0" title="0">if age &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                weeks := int(age.Hours() / (24 * 7))
                return fmt.Sprintf("%d weeks ago", weeks)
        }</span>
        <span class="cov0" title="0">if age &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                months := int(age.Hours() / (24 * 30))
                return fmt.Sprintf("%d months ago", months)
        }</span>
        <span class="cov0" title="0">years := int(age.Hours() / (24 * 365))
        return fmt.Sprintf("%d years ago", years)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package modes

import (
        "fmt"
        "time"

        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// CompactDisplay provides terminal-friendly minimal output
type CompactDisplay struct{}

// NewCompactDisplay creates a new compact display mode
func NewCompactDisplay() *CompactDisplay <span class="cov0" title="0">{
        return &amp;CompactDisplay{}
}</span>

// Name returns the display mode name
func (cd *CompactDisplay) Name() string <span class="cov0" title="0">{
        return "compact"
}</span>

// MinWidth returns the minimum terminal width for this display
func (cd *CompactDisplay) MinWidth() int <span class="cov0" title="0">{
        return 60
}</span>

// Render displays archives in compact format
func (cd *CompactDisplay) Render(archives []*storage.Archive, opts display.Options) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                if !opts.ShowHeaders </span><span class="cov0" title="0">{
                        // Script-friendly: just return silently
                        return nil
                }</span>
                <span class="cov0" title="0">fmt.Printf("No archives found\n")
                return nil</span>
        }

        // Group archives by status for summary
        <span class="cov0" title="0">var activeCount, missingCount, deletedCount int
        for _, a := range archives </span><span class="cov0" title="0">{
                switch a.Status </span>{
                case "deleted":<span class="cov0" title="0">
                        deletedCount++</span>
                case "missing":<span class="cov0" title="0">
                        missingCount++</span>
                default:<span class="cov0" title="0">
                        activeCount++</span>
                }
        }

        // Print compact summary (unless headers disabled)
        <span class="cov0" title="0">if opts.ShowHeaders </span><span class="cov0" title="0">{
                fmt.Printf("%d archives", len(archives))
                if missingCount &gt; 0 || deletedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf(" (%d active", activeCount)
                        if missingCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(", %d missing", missingCount)
                        }</span>
                        <span class="cov0" title="0">if deletedCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(", %d deleted", deletedCount)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf(")")</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Print each archive in compact format
        <span class="cov0" title="0">for _, archive := range archives </span><span class="cov0" title="0">{
                cd.printCompactArchive(archive, opts)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// printCompactArchive prints a single archive in compact format
func (cd *CompactDisplay) printCompactArchive(archive *storage.Archive, opts display.Options) <span class="cov0" title="0">{
        // Format: ID  name  size  age  status

        // Truncate ID to 12 chars for consistency with show command
        id := archive.UID
        if len(id) &gt; 12 </span><span class="cov0" title="0">{
                id = id[:12]
        }</span>

        // Truncate name for compact display
        <span class="cov0" title="0">name := archive.Name
        if len(name) &gt; 25 </span><span class="cov0" title="0">{
                name = name[:24] + "…"
        }</span>

        // Format size compactly
        <span class="cov0" title="0">size := display.FormatSize(archive.Size)

        // Format age compactly
        age := formatCompactAge(archive.Created)

        // Format status compactly
        status := cd.formatCompactStatus(archive)

        if opts.Details </span><span class="cov0" title="0">{
                // Detailed compact: add profile and managed indicator
                profile := archive.Profile
                if profile == "" </span><span class="cov0" title="0">{
                        profile = "-"
                }</span>
                <span class="cov0" title="0">if len(profile) &gt; 8 </span><span class="cov0" title="0">{
                        profile = profile[:7] + "…"
                }</span>

                <span class="cov0" title="0">location := "EXTERNAL"
                if archive.Managed </span><span class="cov0" title="0">{
                        location = "MANAGED"
                }</span>

                <span class="cov0" title="0">fmt.Printf("%-12s  %-25s  %8s  %-8s  %3s  %-8s  %s\n",
                        id, name, size, profile, age, location, status)</span>
        } else<span class="cov0" title="0"> {
                // Basic compact format
                fmt.Printf("%-12s  %-25s  %8s  %3s  %s\n",
                        id, name, size, age, status)
        }</span>
}

// formatCompactStatus returns a compact status indicator
func (cd *CompactDisplay) formatCompactStatus(archive *storage.Archive) string <span class="cov0" title="0">{
        return display.FormatStatus(archive.Status, false) // Use text format for compact
}</span>

// formatCompactAge formats duration in a very compact way
func formatCompactAge(created time.Time) string <span class="cov0" title="0">{
        age := time.Since(created)

        if age &lt; time.Minute </span><span class="cov0" title="0">{
                return "now"
        }</span>
        <span class="cov0" title="0">if age &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", int(age.Minutes()))
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", int(age.Hours()))
        }</span>
        <span class="cov0" title="0">if age &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd", int(age.Hours()/24))
        }</span>
        <span class="cov0" title="0">if age &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dw", int(age.Hours()/(24*7)))
        }</span>
        <span class="cov0" title="0">if age &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dmo", int(age.Hours()/(24*30)))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dy", int(age.Hours()/(24*365)))</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package modes

import (
        "fmt"
        "sort"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// DashboardDisplay provides management overview and statistics
type DashboardDisplay struct{}

// NewDashboardDisplay creates a new dashboard display mode
func NewDashboardDisplay() *DashboardDisplay <span class="cov0" title="0">{
        return &amp;DashboardDisplay{}
}</span>

// Name returns the display mode name
func (dd *DashboardDisplay) Name() string <span class="cov0" title="0">{
        return "dashboard"
}</span>

// MinWidth returns the minimum terminal width for this display
func (dd *DashboardDisplay) MinWidth() int <span class="cov0" title="0">{
        return 90
}</span>

// Render displays archives in dashboard format
func (dd *DashboardDisplay) Render(archives []*storage.Archive, opts display.Options) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                dd.printEmptyDashboard()
                return nil
        }</span>

        // Generate statistics
        <span class="cov0" title="0">stats := dd.generateStatistics(archives)

        // Print dashboard header
        dd.printHeader()

        // Print overview section
        dd.printOverview(stats)

        // Print storage breakdown
        dd.printStorageBreakdown(stats)

        // Print status summary
        dd.printStatusSummary(stats)

        // Print profile distribution
        dd.printProfileDistribution(stats)

        // Print recent activity
        dd.printRecentActivity(stats)

        // Print health indicators
        dd.printHealthIndicators(stats)

        return nil</span>
}

// Statistics holds dashboard metrics
type Statistics struct {
        Total               int
        ManagedCount        int
        ExternalCount       int
        ActiveCount         int
        MissingCount        int
        DeletedCount        int
        TotalSize           int64
        ManagedSize         int64
        ExternalSize        int64
        ProfileDistribution map[string]int
        ProfileSizes        map[string]int64
        OldestArchive       *storage.Archive
        NewestArchive       *storage.Archive
        LargestArchive      *storage.Archive
        RecentArchives      []*storage.Archive
        DeletionCandidates  []*storage.Archive
        HealthScore         float64
}

// generateStatistics computes dashboard metrics
func (dd *DashboardDisplay) generateStatistics(archives []*storage.Archive) Statistics <span class="cov0" title="0">{
        stats := Statistics{
                ProfileDistribution: make(map[string]int),
                ProfileSizes:        make(map[string]int64),
        }

        var allActive []*storage.Archive

        for _, archive := range archives </span><span class="cov0" title="0">{
                stats.Total++
                stats.TotalSize += archive.Size

                // Count by status
                switch archive.Status </span>{
                case "deleted":<span class="cov0" title="0">
                        stats.DeletedCount++</span>
                case "missing":<span class="cov0" title="0">
                        stats.MissingCount++
                        stats.ActiveCount++</span>
                default:<span class="cov0" title="0">
                        stats.ActiveCount++
                        allActive = append(allActive, archive)</span>
                }

                // Count by location
                <span class="cov0" title="0">if archive.Managed </span><span class="cov0" title="0">{
                        stats.ManagedCount++
                        stats.ManagedSize += archive.Size
                }</span> else<span class="cov0" title="0"> {
                        stats.ExternalCount++
                        stats.ExternalSize += archive.Size
                }</span>

                // Profile distribution
                <span class="cov0" title="0">profile := archive.Profile
                if profile == "" </span><span class="cov0" title="0">{
                        profile = "default"
                }</span>
                <span class="cov0" title="0">stats.ProfileDistribution[profile]++
                stats.ProfileSizes[profile] += archive.Size

                // Track extremes
                if stats.OldestArchive == nil || archive.Created.Before(stats.OldestArchive.Created) </span><span class="cov0" title="0">{
                        stats.OldestArchive = archive
                }</span>
                <span class="cov0" title="0">if stats.NewestArchive == nil || archive.Created.After(stats.NewestArchive.Created) </span><span class="cov0" title="0">{
                        stats.NewestArchive = archive
                }</span>
                <span class="cov0" title="0">if stats.LargestArchive == nil || archive.Size &gt; stats.LargestArchive.Size </span><span class="cov0" title="0">{
                        stats.LargestArchive = archive
                }</span>
        }

        // Sort for recent archives (last 5)
        <span class="cov0" title="0">sort.Slice(allActive, func(i, j int) bool </span><span class="cov0" title="0">{
                return allActive[i].Created.After(allActive[j].Created)
        }</span>)

        <span class="cov0" title="0">recentCount := 5
        if len(allActive) &lt; recentCount </span><span class="cov0" title="0">{
                recentCount = len(allActive)
        }</span>
        <span class="cov0" title="0">stats.RecentArchives = allActive[:recentCount]

        // Calculate health score
        stats.HealthScore = dd.calculateHealthScore(stats)

        return stats</span>
}

// calculateHealthScore computes an overall health percentage
func (dd *DashboardDisplay) calculateHealthScore(stats Statistics) float64 <span class="cov0" title="0">{
        if stats.Total == 0 </span><span class="cov0" title="0">{
                return 100.0
        }</span>

        <span class="cov0" title="0">score := 100.0

        // Deduct for missing archives
        missingPenalty := float64(stats.MissingCount) / float64(stats.Total) * 30.0
        score -= missingPenalty

        // Deduct for deleted archives (less severe)
        deletedPenalty := float64(stats.DeletedCount) / float64(stats.Total) * 10.0
        score -= deletedPenalty

        // Ensure score doesn't go below 0
        if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span>

        <span class="cov0" title="0">return score</span>
}

// printEmptyDashboard shows dashboard when no archives exist
func (dd *DashboardDisplay) printEmptyDashboard() <span class="cov0" title="0">{
        fmt.Printf("╔══════════════════════════════════════════════════════════════════════════════╗\n")
        fmt.Printf("║                               7ZARCH DASHBOARD                               ║\n")
        fmt.Printf("╠══════════════════════════════════════════════════════════════════════════════╣\n")
        fmt.Printf("║                                                                              ║\n")
        fmt.Printf("║                         📦 No archives found                                ║\n")
        fmt.Printf("║                                                                              ║\n")
        fmt.Printf("║                 Create archives with '7zarch-go create &lt;path&gt;'               ║\n")
        fmt.Printf("║                          to see them in this dashboard                      ║\n")
        fmt.Printf("║                                                                              ║\n")
        fmt.Printf("╚══════════════════════════════════════════════════════════════════════════════╝\n")
}</span>

// printHeader prints the dashboard header
func (dd *DashboardDisplay) printHeader() <span class="cov0" title="0">{
        timestamp := fmt.Sprintf("Generated: %s", time.Now().Format("2006-01-02 15:04:05"))
        // Calculate padding for centering the timestamp (80 chars total width)
        padding := (80 - len(timestamp)) / 2
        if padding &lt; 0 </span><span class="cov0" title="0">{
                padding = 0
        }</span>

        <span class="cov0" title="0">fmt.Printf("╔════════════════════════════════════════════════════════════════════════════════╗\n")
        fmt.Printf("                               7ZARCH DASHBOARD\n")
        fmt.Printf("%s%s\n", strings.Repeat(" ", padding), timestamp)
        fmt.Printf("╚════════════════════════════════════════════════════════════════════════════════╝\n")</span>
}

// printOverview prints the main statistics overview
func (dd *DashboardDisplay) printOverview(stats Statistics) <span class="cov0" title="0">{
        fmt.Printf("\n┌─ OVERVIEW ─────────────────────────────────────────────────────────────────────┐\n")

        // Align content with section header text
        fmt.Printf("│  Total Archives: %-10d  Storage Used: %-15s  Health: %.1f%%\n",
                stats.Total, display.FormatSize(stats.TotalSize), stats.HealthScore)
        fmt.Printf("│  Active: %-12d  Missing: %-10d  Deleted: %-10d\n",
                stats.ActiveCount, stats.MissingCount, stats.DeletedCount)

        fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")
}</span>

// printStorageBreakdown shows storage location distribution
func (dd *DashboardDisplay) printStorageBreakdown(stats Statistics) <span class="cov0" title="0">{
        fmt.Printf("\n┌─ STORAGE BREAKDOWN ────────────────────────────────────────────────────────────┐\n")

        managedPercent := 0.0
        externalPercent := 0.0
        if stats.TotalSize &gt; 0 </span><span class="cov0" title="0">{
                managedPercent = float64(stats.ManagedSize) / float64(stats.TotalSize) * 100
                externalPercent = float64(stats.ExternalSize) / float64(stats.TotalSize) * 100
        }</span>

        // Align content with section header text
        <span class="cov0" title="0">fmt.Printf("│  Managed Storage:  %3d archives  %15s  (%5.1f%%)\n",
                stats.ManagedCount, display.FormatSize(stats.ManagedSize), managedPercent)
        fmt.Printf("│  External Storage: %3d archives  %15s  (%5.1f%%)\n",
                stats.ExternalCount, display.FormatSize(stats.ExternalSize), externalPercent)

        fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")</span>
}

// printStatusSummary shows detailed status information
func (dd *DashboardDisplay) printStatusSummary(stats Statistics) <span class="cov0" title="0">{
        fmt.Printf("\n┌─ STATUS SUMMARY ───────────────────────────────────────────────────────────────┐\n")

        presentCount := stats.ActiveCount - stats.MissingCount
        presentIcon := display.FormatStatus("present", true)
        fmt.Printf("│  %s Present:  %3d archives\n", presentIcon, presentCount)

        if stats.MissingCount &gt; 0 </span><span class="cov0" title="0">{
                missingIcon := display.FormatStatus("missing", true)
                fmt.Printf("│  %s Missing:  %3d archives  (requires attention)\n", missingIcon, stats.MissingCount)
        }</span>

        <span class="cov0" title="0">if stats.DeletedCount &gt; 0 </span><span class="cov0" title="0">{
                deletedIcon := display.FormatStatus("deleted", true)
                fmt.Printf("│  %s Deleted:  %3d archives  (auto-purge in 7 days)\n", deletedIcon, stats.DeletedCount)
        }</span>

        <span class="cov0" title="0">fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")</span>
}

// printProfileDistribution shows profile usage statistics
func (dd *DashboardDisplay) printProfileDistribution(stats Statistics) <span class="cov0" title="0">{
        if len(stats.ProfileDistribution) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n┌─ PROFILE DISTRIBUTION ─────────────────────────────────────────────────────────┐\n")

        // Sort profiles by count for consistent display
        type profileStat struct {
                name  string
                count int
                size  int64
        }

        var profiles []profileStat
        for name, count := range stats.ProfileDistribution </span><span class="cov0" title="0">{
                profiles = append(profiles, profileStat{
                        name:  name,
                        count: count,
                        size:  stats.ProfileSizes[name],
                })
        }</span>

        <span class="cov0" title="0">sort.Slice(profiles, func(i, j int) bool </span><span class="cov0" title="0">{
                return profiles[i].count &gt; profiles[j].count
        }</span>)

        <span class="cov0" title="0">for _, profile := range profiles </span><span class="cov0" title="0">{
                percent := float64(profile.count) / float64(stats.Total) * 100
                fmt.Printf("│  %-12s: %3d archives  %15s  (%5.1f%%)\n",
                        profile.name, profile.count, display.FormatSize(profile.size), percent)
        }</span>

        <span class="cov0" title="0">fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")</span>
}

// printRecentActivity shows recently created archives
func (dd *DashboardDisplay) printRecentActivity(stats Statistics) <span class="cov0" title="0">{
        if len(stats.RecentArchives) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n┌─ RECENT ACTIVITY ──────────────────────────────────────────────────────────────┐\n")

        for _, archive := range stats.RecentArchives </span><span class="cov0" title="0">{
                age := dd.formatDashboardAge(archive.Created)
                size := display.FormatSize(archive.Size)
                name := archive.Name
                if len(name) &gt; 35 </span><span class="cov0" title="0">{
                        name = name[:34] + "…"
                }</span>

                <span class="cov0" title="0">status := display.FormatStatus(archive.Status, true)

                // Align content with section header text
                fmt.Printf("│  %s %-35s  %8s  %s\n", status, name, size, age)</span>
        }

        <span class="cov0" title="0">fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")</span>
}

// printHealthIndicators shows system health metrics
func (dd *DashboardDisplay) printHealthIndicators(stats Statistics) <span class="cov0" title="0">{
        fmt.Printf("\n┌─ HEALTH INDICATORS ────────────────────────────────────────────────────────────┐\n")

        // Overall health
        healthStatus := "Excellent"
        if stats.HealthScore &lt; 90 </span><span class="cov0" title="0">{
                healthStatus = "Good"
        }</span>
        <span class="cov0" title="0">if stats.HealthScore &lt; 70 </span><span class="cov0" title="0">{
                healthStatus = "Fair"
        }</span>
        <span class="cov0" title="0">if stats.HealthScore &lt; 50 </span><span class="cov0" title="0">{
                healthStatus = "Poor"
        }</span>

        <span class="cov0" title="0">fmt.Printf("│  Overall Health: %.1f%% (%s)\n", stats.HealthScore, healthStatus)

        // Size metrics
        if stats.LargestArchive != nil </span><span class="cov0" title="0">{
                avgSize := stats.TotalSize / int64(stats.Total)
                fmt.Printf("│  Average Size: %s    Largest: %s\n",
                        display.FormatSize(avgSize), display.FormatSize(stats.LargestArchive.Size))
        }</span>

        // Age metrics
        <span class="cov0" title="0">if stats.OldestArchive != nil &amp;&amp; stats.NewestArchive != nil </span><span class="cov0" title="0">{
                oldestAge := dd.formatDashboardAge(stats.OldestArchive.Created)
                newestAge := dd.formatDashboardAge(stats.NewestArchive.Created)
                fmt.Printf("│  Archive Age Range: %s (oldest) to %s (newest)\n", oldestAge, newestAge)
        }</span>

        <span class="cov0" title="0">fmt.Printf("└────────────────────────────────────────────────────────────────────────────────┘\n")</span>
}

// formatDashboardAge formats duration for dashboard display
func (dd *DashboardDisplay) formatDashboardAge(created time.Time) string <span class="cov0" title="0">{
        age := time.Since(created)

        if age &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm ago", int(age.Minutes()))
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh ago", int(age.Hours()))
        }</span>
        <span class="cov0" title="0">if age &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd ago", int(age.Hours()/24))
        }</span>
        <span class="cov0" title="0">if age &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dw ago", int(age.Hours()/(24*7)))
        }</span>
        <span class="cov0" title="0">if age &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dmo ago", int(age.Hours()/(24*30)))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dy ago", int(age.Hours()/(24*365)))</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package modes

import (
        "fmt"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// TableDisplay provides high-density information scanning
type TableDisplay struct{}

// NewTableDisplay creates a new table display mode
func NewTableDisplay() *TableDisplay <span class="cov0" title="0">{
        return &amp;TableDisplay{}
}</span>

// Name returns the display mode name
func (td *TableDisplay) Name() string <span class="cov0" title="0">{
        return "table"
}</span>

// MinWidth returns the minimum terminal width for this display
func (td *TableDisplay) MinWidth() int <span class="cov0" title="0">{
        return 80
}</span>

// Render displays archives in an enhanced table format
func (td *TableDisplay) Render(archives []*storage.Archive, opts display.Options) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("📦 No archives found\n")
                fmt.Printf("💡 Tip: Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Group archives by status
        <span class="cov0" title="0">var managedActive, externalActive, deleted []*storage.Archive
        var missingCount int

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deleted = append(deleted, a)
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedActive = append(managedActive, a)
                }</span> else<span class="cov0" title="0"> {
                        externalActive = append(externalActive, a)
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        // Print summary header
        <span class="cov0" title="0">td.printSummary(len(archives), len(managedActive), len(externalActive), missingCount, len(deleted))

        // Configure columns based on terminal width and options
        columns := td.selectColumns(opts)

        // Print active archives
        if len(managedActive) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nACTIVE - MANAGED\n")
                td.printTable(managedActive, columns, opts)
        }</span>

        <span class="cov0" title="0">if len(externalActive) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nACTIVE - EXTERNAL\n")
                td.printTable(externalActive, columns, opts)
        }</span>

        // Print deleted archives
        <span class="cov0" title="0">if len(deleted) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nDELETED (auto-purge in 7 days)\n")
                td.printTable(deleted, columns, opts)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// printSummary prints the archive summary header
func (td *TableDisplay) printSummary(total, managed, external, missing, deleted int) <span class="cov0" title="0">{
        fmt.Printf("📦 Archives (%d found)\n", total)
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n",
                managed+external, managed, external, missing, deleted)
}</span>

// Column represents a table column
type Column struct {
        Name   string
        Width  int
        Format func(*storage.Archive) string
}

// selectColumns determines which columns to show based on options
func (td *TableDisplay) selectColumns(opts display.Options) []Column <span class="cov0" title="0">{
        // Default columns for basic mode
        columns := []Column{
                {
                        Name:  "ID",
                        Width: 13,
                        Format: func(a *storage.Archive) string </span><span class="cov0" title="0">{
                                id := a.UID
                                if len(id) &gt; 12 </span><span class="cov0" title="0">{
                                        id = id[:12]
                                }</span>
                                <span class="cov0" title="0">return id</span>
                        },
                },
                {
                        Name:  "Name",
                        Width: 30,
                        Format: func(a *storage.Archive) string <span class="cov0" title="0">{
                                return display.TruncateString(a.Name, 30)
                        }</span>,
                },
                {
                        Name:  "Size",
                        Width: 9,
                        Format: func(a *storage.Archive) string <span class="cov0" title="0">{
                                return display.FormatSize(a.Size)
                        }</span>,
                },
        }

        // Add detailed columns if requested
        <span class="cov0" title="0">if opts.Details </span><span class="cov0" title="0">{
                columns = append(columns,
                        Column{
                                Name:  "Profile",
                                Width: 10,
                                Format: func(a *storage.Archive) string </span><span class="cov0" title="0">{
                                        if a.Profile == "" </span><span class="cov0" title="0">{
                                                return "-"
                                        }</span>
                                        <span class="cov0" title="0">return display.TruncateString(a.Profile, 10)</span>
                                },
                        },
                        Column{
                                Name:  "Created",
                                Width: 20,
                                Format: func(a *storage.Archive) string <span class="cov0" title="0">{
                                        return a.Created.Format("2006-01-02 15:04:05")
                                }</span>,
                        },
                        Column{
                                Name:  "Age",
                                Width: 7,
                                Format: func(a *storage.Archive) string <span class="cov0" title="0">{
                                        return formatAge(a.Created)
                                }</span>,
                        },
                )
        }

        // Status column always last
        <span class="cov0" title="0">columns = append(columns, Column{
                Name:  "Status",
                Width: 7,
                Format: func(a *storage.Archive) string </span><span class="cov0" title="0">{
                        return display.FormatStatus(a.Status, false) // Use text format for table
                }</span>,
        })

        // Adjust column widths for terminal width if needed
        <span class="cov0" title="0">if opts.Width &gt; 0 </span><span class="cov0" title="0">{
                td.adjustColumnWidths(columns, opts.Width)
        }</span>

        <span class="cov0" title="0">return columns</span>
}

// adjustColumnWidths adapts column widths to fit terminal
func (td *TableDisplay) adjustColumnWidths(columns []Column, termWidth int) <span class="cov0" title="0">{
        // Calculate total width needed
        totalWidth := 0
        for _, col := range columns </span><span class="cov0" title="0">{
                totalWidth += col.Width + 2 // +2 for spacing
        }</span>

        // If we're over terminal width, adjust the Name column
        <span class="cov0" title="0">if totalWidth &gt; termWidth &amp;&amp; len(columns) &gt; 1 </span><span class="cov0" title="0">{
                excess := totalWidth - termWidth
                for i := range columns </span><span class="cov0" title="0">{
                        if columns[i].Name == "Name" </span><span class="cov0" title="0">{
                                columns[i].Width = max(15, columns[i].Width-excess)
                                break</span>
                        }
                }
        }
}

// printTable prints archives in table format
func (td *TableDisplay) printTable(archives []*storage.Archive, columns []Column, opts display.Options) <span class="cov0" title="0">{
        // Print header with borders
        if opts.ShowHeaders </span><span class="cov0" title="0">{
                td.printBorder(columns, "top")
                td.printHeader(columns)
                td.printBorder(columns, "middle")
        }</span>

        // Print rows
        <span class="cov0" title="0">for _, archive := range archives </span><span class="cov0" title="0">{
                td.printRow(archive, columns)
        }</span>

        // Always print bottom border for clean look
        <span class="cov0" title="0">td.printBorder(columns, "bottom")

        fmt.Println()</span>
}

// printBorder prints table borders
func (td *TableDisplay) printBorder(columns []Column, position string) <span class="cov0" title="0">{
        var left, middle, right, horizontal string

        switch position </span>{
        case "top":<span class="cov0" title="0">
                left, middle, right, horizontal = "┌", "┬", "┐", "─"</span>
        case "middle":<span class="cov0" title="0">
                left, middle, right, horizontal = "├", "┼", "┤", "─"</span>
        case "bottom":<span class="cov0" title="0">
                left, middle, right, horizontal = "└", "┴", "┘", "─"</span>
        }

        <span class="cov0" title="0">fmt.Print(left)
        for i, col := range columns </span><span class="cov0" title="0">{
                // Add 1 for left padding space
                fmt.Print(strings.Repeat(horizontal, col.Width+1))
                if i &lt; len(columns)-1 </span><span class="cov0" title="0">{
                        fmt.Print(middle)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println(right)</span>
}

// printHeader prints the table header
func (td *TableDisplay) printHeader(columns []Column) <span class="cov0" title="0">{
        fmt.Print("│")
        for _, col := range columns </span><span class="cov0" title="0">{
                fmt.Printf(" %-*s│", col.Width, col.Name)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

// printRow prints a single archive row
func (td *TableDisplay) printRow(archive *storage.Archive, columns []Column) <span class="cov0" title="0">{
        fmt.Print("│")
        for _, col := range columns </span><span class="cov0" title="0">{
                value := col.Format(archive)
                fmt.Printf(" %-*s│", col.Width, value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

// formatAge formats duration since creation
func formatAge(created time.Time) string <span class="cov0" title="0">{
        age := time.Since(created)

        if age &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", int(age.Minutes()))
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", int(age.Hours()))
        }</span>
        <span class="cov0" title="0">if age &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd", int(age.Hours()/24))
        }</span>
        <span class="cov0" title="0">if age &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dw", int(age.Hours()/(24*7)))
        }</span>
        <span class="cov0" title="0">if age &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dmo", int(age.Hours()/(24*30)))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dy", int(age.Hours()/(24*365)))</span>
}

// max returns the larger of two integers
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package modes

import (
        "fmt"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/adamstac/7zarch-go/internal/display"
        "github.com/adamstac/7zarch-go/internal/storage"
)

// TreeDisplay provides hierarchical grouping of archives
type TreeDisplay struct{}

// NewTreeDisplay creates a new tree display mode
func NewTreeDisplay() *TreeDisplay <span class="cov0" title="0">{
        return &amp;TreeDisplay{}
}</span>

// Name returns the display mode name
func (td *TreeDisplay) Name() string <span class="cov0" title="0">{
        return "tree"
}</span>

// MinWidth returns the minimum terminal width for this display
func (td *TreeDisplay) MinWidth() int <span class="cov0" title="0">{
        return 70
}</span>

// Render displays archives in tree format
func (td *TreeDisplay) Render(archives []*storage.Archive, opts display.Options) error <span class="cov0" title="0">{
        if len(archives) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No archives found\n")
                fmt.Printf("Create archives with '7zarch-go create &lt;path&gt;' to see them here.\n")
                return nil
        }</span>

        // Group archives by directory structure
        <span class="cov0" title="0">tree := td.buildDirectoryTree(archives)

        // Print summary header
        td.printSummary(archives)

        // Print the tree
        fmt.Printf("\nDirectory Structure:\n")
        td.printTree(tree, "", true, opts)

        return nil</span>
}

// DirectoryNode represents a node in the directory tree
type DirectoryNode struct {
        Name     string
        Path     string
        Archives []*storage.Archive
        Children map[string]*DirectoryNode
        IsRoot   bool
}

// buildDirectoryTree creates a hierarchical structure from archives
func (td *TreeDisplay) buildDirectoryTree(archives []*storage.Archive) *DirectoryNode <span class="cov0" title="0">{
        root := &amp;DirectoryNode{
                Name:     "Archives",
                Children: make(map[string]*DirectoryNode),
                IsRoot:   true,
        }

        // Group archives by their directory paths
        for _, archive := range archives </span><span class="cov0" title="0">{
                td.addToTree(root, archive)
        }</span>

        <span class="cov0" title="0">return root</span>
}

// addToTree adds an archive to the appropriate place in the tree
func (td *TreeDisplay) addToTree(root *DirectoryNode, archive *storage.Archive) <span class="cov0" title="0">{
        // Determine the grouping path
        var groupPath string

        if archive.Managed </span><span class="cov0" title="0">{
                // For managed archives, group by storage location
                groupPath = "Managed Storage"
        }</span> else<span class="cov0" title="0"> {
                // For external archives, group by directory
                dir := filepath.Dir(archive.Path)
                if dir == "." || dir == "/" </span><span class="cov0" title="0">{
                        groupPath = "Root"
                }</span> else<span class="cov0" title="0"> {
                        groupPath = dir
                }</span>
        }

        // Navigate/create the path in the tree
        <span class="cov0" title="0">current := root
        parts := strings.Split(groupPath, string(filepath.Separator))

        for _, part := range parts </span><span class="cov0" title="0">{
                if part == "" || part == "." </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, exists := current.Children[part]; !exists </span><span class="cov0" title="0">{
                        current.Children[part] = &amp;DirectoryNode{
                                Name:     part,
                                Path:     part,
                                Children: make(map[string]*DirectoryNode),
                        }
                }</span>
                <span class="cov0" title="0">current = current.Children[part]</span>
        }

        // Add archive to the final node
        <span class="cov0" title="0">current.Archives = append(current.Archives, archive)</span>
}

// printSummary prints the archive summary
func (td *TreeDisplay) printSummary(archives []*storage.Archive) <span class="cov0" title="0">{
        var managedCount, externalCount, missingCount, deletedCount int

        for _, a := range archives </span><span class="cov0" title="0">{
                if a.Status == "deleted" </span><span class="cov0" title="0">{
                        deletedCount++
                }</span> else<span class="cov0" title="0"> if a.Managed </span><span class="cov0" title="0">{
                        managedCount++
                }</span> else<span class="cov0" title="0"> {
                        externalCount++
                }</span>
                <span class="cov0" title="0">if a.Status == "missing" </span><span class="cov0" title="0">{
                        missingCount++
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("Archive Collection (%d archives found)\n", len(archives))
        fmt.Printf("Active: %d (Managed: %d, External: %d) | Missing: %d | Deleted: %d\n",
                managedCount+externalCount, managedCount, externalCount, missingCount, deletedCount)</span>
}

// printTree recursively prints the directory tree
func (td *TreeDisplay) printTree(node *DirectoryNode, prefix string, isLast bool, opts display.Options) <span class="cov0" title="0">{
        if !node.IsRoot </span><span class="cov0" title="0">{
                // Print directory name
                connector := "├── "
                if isLast </span><span class="cov0" title="0">{
                        connector = "└── "
                }</span>

                <span class="cov0" title="0">fmt.Printf("%s%s%s", prefix, connector, node.Name)

                // Add archive count if any
                if len(node.Archives) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf(" (%d archives)", len(node.Archives))
                }</span>
                <span class="cov0" title="0">fmt.Println()

                // Print archives in this directory
                if len(node.Archives) &gt; 0 </span><span class="cov0" title="0">{
                        td.printArchivesInDirectory(node.Archives, prefix, isLast, opts)
                }</span>
        }

        // Sort children by name for consistent output
        <span class="cov0" title="0">var childNames []string
        for name := range node.Children </span><span class="cov0" title="0">{
                childNames = append(childNames, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(childNames)

        // Print child directories
        for i, childName := range childNames </span><span class="cov0" title="0">{
                child := node.Children[childName]
                childIsLast := i == len(childNames)-1

                var childPrefix string
                if node.IsRoot </span><span class="cov0" title="0">{
                        childPrefix = ""
                }</span> else<span class="cov0" title="0"> if isLast </span><span class="cov0" title="0">{
                        childPrefix = prefix + "    "
                }</span> else<span class="cov0" title="0"> {
                        childPrefix = prefix + "│   "
                }</span>

                <span class="cov0" title="0">td.printTree(child, childPrefix, childIsLast, opts)</span>
        }
}

// printArchivesInDirectory prints archives within a directory node
func (td *TreeDisplay) printArchivesInDirectory(archives []*storage.Archive, prefix string, isLast bool, opts display.Options) <span class="cov0" title="0">{
        // Sort archives by name
        sort.Slice(archives, func(i, j int) bool </span><span class="cov0" title="0">{
                return archives[i].Name &lt; archives[j].Name
        }</span>)

        <span class="cov0" title="0">for i, archive := range archives </span><span class="cov0" title="0">{
                archiveIsLast := i == len(archives)-1

                var archivePrefix string
                if isLast </span><span class="cov0" title="0">{
                        archivePrefix = prefix + "    "
                }</span> else<span class="cov0" title="0"> {
                        archivePrefix = prefix + "│   "
                }</span>

                <span class="cov0" title="0">connector := "├── "
                if archiveIsLast </span><span class="cov0" title="0">{
                        connector = "└── "
                }</span>

                // Format archive entry
                <span class="cov0" title="0">status := td.formatTreeStatus(archive)
                size := display.FormatSize(archive.Size)
                age := td.formatTreeAge(archive.Created)

                fmt.Printf("%s%s📦 %s", archivePrefix, connector, archive.Name)

                if opts.Details </span><span class="cov0" title="0">{
                        // Show detailed info
                        id := archive.UID
                        if len(id) &gt; 12 </span><span class="cov0" title="0">{
                                id = id[:12]
                        }</span>
                        <span class="cov0" title="0">profile := archive.Profile
                        if profile == "" </span><span class="cov0" title="0">{
                                profile = "default"
                        }</span>

                        <span class="cov0" title="0">fmt.Printf(" [%s] (%s, %s, %s, %s)", id, size, profile, age, status)</span>
                } else<span class="cov0" title="0"> {
                        // Show basic info
                        fmt.Printf(" (%s, %s, %s)", size, age, status)
                }</span>

                <span class="cov0" title="0">fmt.Println()</span>
        }
}

// formatTreeStatus returns a formatted status for tree display
func (td *TreeDisplay) formatTreeStatus(archive *storage.Archive) string <span class="cov0" title="0">{
        return display.FormatStatus(archive.Status, true) // Use icons for tree
}</span>

// formatTreeAge formats duration since creation for tree display
func (td *TreeDisplay) formatTreeAge(created time.Time) string <span class="cov0" title="0">{
        age := time.Since(created)

        if age &lt; time.Hour </span><span class="cov0" title="0">{
                mins := int(age.Minutes())
                return fmt.Sprintf("%dm", mins)
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(age.Hours())
                return fmt.Sprintf("%dh", hours)
        }</span>
        <span class="cov0" title="0">if age &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                days := int(age.Hours() / 24)
                return fmt.Sprintf("%dd", days)
        }</span>
        <span class="cov0" title="0">if age &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                weeks := int(age.Hours() / (24 * 7))
                return fmt.Sprintf("%dw", weeks)
        }</span>
        <span class="cov0" title="0">if age &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                months := int(age.Hours() / (24 * 30))
                return fmt.Sprintf("%dmo", months)
        }</span>
        <span class="cov0" title="0">years := int(age.Hours() / (24 * 365))
        return fmt.Sprintf("%dy", years)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package errors

import (
        "fmt"
        "strings"
)

// ValidationError represents invalid input validation
type ValidationError struct {
        Field   string
        Value   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid %s '%s': %s", e.Field, e.Value, e.Message)
}</span>

// NotFoundError represents a resource that couldn't be located
type NotFoundError struct {
        Resource string
        ID       string
        Suggestions []string
}

func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        base := fmt.Sprintf("%s '%s' not found.", e.Resource, e.ID)
        if len(e.Suggestions) &gt; 0 </span><span class="cov0" title="0">{
                base += fmt.Sprintf(" Try: %s", strings.Join(e.Suggestions, ", "))
        }</span>
        <span class="cov0" title="0">return base</span>
}

// InvalidOperationError represents an operation that cannot be performed
type InvalidOperationError struct {
        Operation string
        Resource  string
        Reason    string
}

func (e *InvalidOperationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Cannot %s %s: %s", e.Operation, e.Resource, e.Reason)
}</span>

// FileSystemError represents file operation failures
type FileSystemError struct {
        Path      string
        Operation string
        Err       error
}

func (e *FileSystemError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Failed to %s '%s': %v", e.Operation, e.Path, e.Err)
}</span>

func (e *FileSystemError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// DatabaseError represents database operation failures
type DatabaseError struct {
        Operation string
        Table     string
        Err       error
}

func (e *DatabaseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Database %s failed on %s: %v", e.Operation, e.Table, e.Err)
}</span>

func (e *DatabaseError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// ConfigurationError represents configuration issues
type ConfigurationError struct {
        Setting string
        Value   string
        Message string
}

func (e *ConfigurationError) Error() string <span class="cov0" title="0">{
        if e.Value != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Configuration error for %s='%s': %s", e.Setting, e.Value, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Configuration error for %s: %s", e.Setting, e.Message)</span>
}

// Helper functions for common error scenarios

// NewArchiveNotFound creates a standard archive not found error
func NewArchiveNotFound(id string) error <span class="cov0" title="0">{
        return &amp;NotFoundError{
                Resource:    "Archive",
                ID:          id,
                Suggestions: []string{"use 'list' to see available archives", "check the archive ID"},
        }
}</span>

// NewInvalidPath creates a standard invalid path error
func NewInvalidPath(path string, reason string) error <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:   "path",
                Value:   path,
                Message: reason,
        }
}</span>

// NewPermissionDenied creates a standard permission error
func NewPermissionDenied(path string, operation string) error <span class="cov0" title="0">{
        return &amp;FileSystemError{
                Path:      path,
                Operation: operation,
                Err:       fmt.Errorf("permission denied"),
        }
}</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "time"
)

// Archive represents an archive entry in the registry
type Archive struct {
        ID           int64      `json:"id"`
        UID          string     `json:"uid"`
        Name         string     `json:"name"`
        Path         string     `json:"path"`
        Size         int64      `json:"size"`
        Created      time.Time  `json:"created"`
        Checksum     string     `json:"checksum,omitempty"`
        Profile      string     `json:"profile,omitempty"` // compression profile used
        Managed      bool       `json:"managed"`
        Status       string     `json:"status"` // present | missing | deleted
        LastSeen     *time.Time `json:"last_seen,omitempty"`
        DeletedAt    *time.Time `json:"deleted_at,omitempty"`
        OriginalPath string     `json:"original_path,omitempty"`
        Uploaded     bool       `json:"uploaded"`
        Destination  string     `json:"destination,omitempty"` // where it was uploaded
        UploadedAt   *time.Time `json:"uploaded_at,omitempty"`
        Metadata     string     `json:"metadata,omitempty"` // JSON blob for extensibility
}

// IsManaged returns true if this archive is in managed storage
func (a *Archive) IsManaged() bool <span class="cov0" title="0">{
        // Archive is managed if it's in the managed storage path
        // This will be determined by the storage manager
        return a.Path != "" &amp;&amp; len(a.Path) &gt; 0
}</span>

// Age returns the age of the archive
func (a *Archive) Age() time.Duration <span class="cov0" title="0">{
        return time.Since(a.Created)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package storage

import (
        "fmt"
        "strings"
        "time"
)

// Standard error types for MAS operations per 7EP-0004

// ArchiveNotFoundError indicates the requested archive doesn't exist
type ArchiveNotFoundError struct {
        ID string
}

func (e *ArchiveNotFoundError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Archive '%s' not found.\n💡 Use '7zarch-go list' to see available archives", e.ID)
}</span>

// AmbiguousIDError indicates multiple archives match the given ID
type AmbiguousIDError struct {
        ID      string
        Matches []*Archive
}

func (e *AmbiguousIDError) Error() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(fmt.Sprintf("Multiple archives match '%s':\n", e.ID))
        for i, archive := range e.Matches </span><span class="cov0" title="0">{
                location := "managed"
                if !archive.Managed </span><span class="cov0" title="0">{
                        location = "external"
                }</span>
                <span class="cov0" title="0">age := humanizeAge(archive.Created)
                size := humanizeSize(archive.Size)

                prefixLen := 8
                if len(archive.UID) &lt; prefixLen </span><span class="cov0" title="0">{
                        prefixLen = len(archive.UID)
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("[%d] %s %s (%s, %s, %s)\n",
                        i+1,
                        archive.UID[:prefixLen],
                        archive.Name,
                        location,
                        size,
                        age))</span>
        }
        <span class="cov0" title="0">sb.WriteString("\nPlease specify full ULID or use a longer prefix")
        return sb.String()</span>
}

// RegistryError indicates a database operation failure
type RegistryError struct {
        Operation string
        Cause     error
}

func (e *RegistryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Registry operation '%s' failed: %v\n💡 Run '7zarch-go db status' to check registry health",
                e.Operation, e.Cause)
}</span>

// FileVerificationError indicates archive file issues
type FileVerificationError struct {
        Archive *Archive
        Issue   string
}

func (e *FileVerificationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Archive '%s' verification failed: %s\n💡 Use '7zarch-go db verify' to check all archives",
                e.Archive.Name, e.Issue)
}</span>

// Helper functions for error messages

func humanizeAge(t time.Time) string <span class="cov0" title="0">{
        dur := time.Since(t)
        switch </span>{
        case dur &lt; time.Hour:<span class="cov0" title="0">
                return fmt.Sprintf("%dm ago", int(dur.Minutes()))</span>
        case dur &lt; 24*time.Hour:<span class="cov0" title="0">
                return fmt.Sprintf("%dh ago", int(dur.Hours()))</span>
        case dur &lt; 7*24*time.Hour:<span class="cov0" title="0">
                return fmt.Sprintf("%dd ago", int(dur.Hours()/24))</span>
        case dur &lt; 30*24*time.Hour:<span class="cov0" title="0">
                return fmt.Sprintf("%dw ago", int(dur.Hours()/(24*7)))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%dmo ago", int(dur.Hours()/(24*30)))</span>
        }
}

func humanizeSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// Error helpers for consistent messaging

// NotFoundHelp returns helpful suggestions for not found errors
func NotFoundHelp(id string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`Archive not found: %s

Possible causes:
• Archive was deleted (check: 7zarch-go trash list)
• Typo in the ID (check: 7zarch-go list)
• Archive exists but not registered (fix: 7zarch-go import &lt;path&gt;)`, id)
}</span>

// AmbiguousHelp returns helpful suggestions for ambiguous matches
func AmbiguousHelp() string <span class="cov0" title="0">{
        return `💡 Tips for resolving ambiguous matches:
• Use more characters of the ULID (e.g., 01K2E33 instead of 01K)
• Use the full ULID shown in brackets
• Use the archive name if unique`
}</span>

// VerificationHelp returns helpful suggestions for verification failures
func VerificationHelp(issue string) string <span class="cov0" title="0">{
        switch issue </span>{
        case "file not found":<span class="cov0" title="0">
                return `File not found. Possible fixes:
• If moved: 7zarch-go move &lt;id&gt; --reattach &lt;new-path&gt;
• If deleted: 7zarch-go list --missing to see all missing archives
• If on network drive: Check mount status`</span>
        case "checksum mismatch":<span class="cov0" title="0">
                return `Checksum mismatch detected. This archive may be corrupted.
• Create new archive: 7zarch-go create &lt;source&gt;
• Restore from backup if available
• Run full verification: 7zarch-go test &lt;archive&gt;`</span>
        default:<span class="cov0" title="0">
                return "Run '7zarch-go db verify' for comprehensive registry check"</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package storage

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Manager handles the managed storage workspace
type Manager struct {
        basePath string
        registry *Registry
}

// NewManager creates a new storage manager
func NewManager(basePath string) (*Manager, error) <span class="cov8" title="1">{
        // Expand tilde to home directory
        if strings.HasPrefix(basePath, "~/") </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">basePath = filepath.Join(home, basePath[2:])</span>
        }

        // Create the managed storage directory
        <span class="cov8" title="1">archivesPath := filepath.Join(basePath, "archives")
        // #nosec G301: restrict permissions on managed storage directory
        if err := os.MkdirAll(archivesPath, 0750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create managed storage directory: %w", err)
        }</span>

        // Also ensure trash directory exists
        <span class="cov8" title="1">trashPath := filepath.Join(basePath, "trash")
        // #nosec G301: restrict permissions on managed trash directory
        if err := os.MkdirAll(trashPath, 0750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create managed trash directory: %w", err)
        }</span>

        // Initialize the registry
        <span class="cov8" title="1">dbPath := filepath.Join(basePath, "registry.db")
        registry, err := NewRegistry(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize registry: %w", err)
        }</span>
        // Mark current schema baseline/identity as applied for observability
        <span class="cov8" title="1">_ = registry.RecordCurrentSchemaAsApplied()

        // Backfill missing UIDs
        _ = registry.BackfillUIDs(func() string </span><span class="cov0" title="0">{ return generateUID() }</span>)

        <span class="cov8" title="1">return &amp;Manager{
                basePath: basePath,
                registry: registry,
        }, nil</span>
}

// GetManagedPath returns the path where an archive should be stored
func (m *Manager) GetManagedPath(archiveName string) string <span class="cov8" title="1">{
        // For now, use flat organization
        // Later we can add date-based or type-based organization
        return filepath.Join(m.basePath, "archives", archiveName)
}</span>

// Add registers a new archive in the registry
// checksum and metadata are optional; pass empty strings if not available
// managed indicates whether the file is stored under the MAS path
func (m *Manager) Add(name, path string, size int64, profile string, checksum string, metadata string, managed bool) error <span class="cov8" title="1">{
        archive := &amp;Archive{
                UID:      generateUID(),
                Name:     name,
                Path:     path,
                Size:     size,
                Created:  time.Now(),
                Profile:  profile,
                Checksum: checksum,
                Managed:  managed,
                Status:   "present",
                Metadata: metadata,
        }
        return m.registry.Add(archive)
}</span>

// List returns all managed archives
func (m *Manager) List() ([]*Archive, error) <span class="cov8" title="1">{
        return m.registry.List()
}</span>

// ListNotUploaded returns archives that haven't been uploaded
func (m *Manager) ListNotUploaded() ([]*Archive, error) <span class="cov8" title="1">{
        return m.registry.ListNotUploaded()
}</span>

// ListOlderThan returns archives older than the specified duration
func (m *Manager) ListOlderThan(duration time.Duration) ([]*Archive, error) <span class="cov8" title="1">{
        return m.registry.ListOlderThan(duration)
}</span>

// Get retrieves an archive by name
func (m *Manager) Get(name string) (*Archive, error) <span class="cov8" title="1">{
        return m.registry.Get(name)
}</span>

// Registry exposes the underlying registry instance (for DB operations)
func (m *Manager) Registry() *Registry <span class="cov8" title="1">{ return m.registry }</span>

// MarkUploaded marks an archive as uploaded
func (m *Manager) MarkUploaded(name string, destination string) error <span class="cov8" title="1">{
        archive, err := m.registry.Get(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        archive.Uploaded = true
        archive.Destination = destination
        archive.UploadedAt = &amp;now

        return m.registry.Update(archive)</span>
}

// GetBasePath returns the managed base path
func (m *Manager) GetBasePath() string <span class="cov0" title="0">{ return m.basePath }</span>

// GetTrashPath returns the trash directory under managed storage
func (m *Manager) GetTrashPath() string <span class="cov0" title="0">{
        return filepath.Join(m.basePath, "trash")
}</span>

// Delete removes an archive from the registry (does not delete the file)
func (m *Manager) Delete(name string) error <span class="cov0" title="0">{
        return m.registry.Delete(name)
}</span>

// Close closes the storage manager and its registry
func (m *Manager) Close() error <span class="cov8" title="1">{
        if m.registry != nil </span><span class="cov8" title="1">{
                return m.registry.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetArchivesPath returns the path where archives are stored
func (m *Manager) GetArchivesPath() string <span class="cov0" title="0">{
        return filepath.Join(m.basePath, "archives")
}</span>

// Exists checks if an archive exists in the registry
func (m *Manager) Exists(name string) bool <span class="cov0" title="0">{
        if m.registry == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">ok, err := m.registry.Exists(name)
        if err != nil </span><span class="cov0" title="0">{
                // Treat errors as non-existence for now; consider logging in the future
                return false
        }</span>
        <span class="cov0" title="0">return ok</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package storage

import (
        "database/sql"
        "fmt"
        "time"
)

const (
        migrationBaselineID   = "0001_baseline"
        migrationBaselineName = "Baseline schema"

        migrationIdentityID   = "0002_identity_and_status"
        migrationIdentityName = "Add uid/managed/status/last_seen and indexes"
)

// EnsureMigrationsTable creates the schema_migrations table if missing
func (r *Registry) EnsureMigrationsTable() error <span class="cov8" title="1">{
        _, err := r.db.Exec(`CREATE TABLE IF NOT EXISTS schema_migrations (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                applied_at TIMESTAMP NOT NULL
        )`)
        return err
}</span>

// IsMigrationApplied checks if a migration id is recorded
func (r *Registry) IsMigrationApplied(id string) (bool, error) <span class="cov8" title="1">{
        row := r.db.QueryRow(`SELECT 1 FROM schema_migrations WHERE id = ?`, id)
        var one int
        switch err := row.Scan(&amp;one); err </span>{
        case sql.ErrNoRows:<span class="cov8" title="1">
                return false, nil</span>
        case nil:<span class="cov8" title="1">
                return true, nil</span>
        default:<span class="cov0" title="0">
                return false, err</span>
        }
}

// MarkMigrationApplied records a migration as applied
func (r *Registry) MarkMigrationApplied(id, name string) error <span class="cov8" title="1">{
        _, err := r.db.Exec(`INSERT OR REPLACE INTO schema_migrations (id, name, applied_at) VALUES (?, ?, ?)`, id, name, time.Now())
        return err
}</span>

// RecordCurrentSchemaAsApplied marks baseline and identity migrations as applied
// if the current schema already contains their effects (idempotent).
func (r *Registry) RecordCurrentSchemaAsApplied() error <span class="cov8" title="1">{
        if err := r.EnsureMigrationsTable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // If archives table exists, we can mark baseline applied
        <span class="cov8" title="1">if tableExists(r.db, "archives") </span><span class="cov8" title="1">{
                applied, err := r.IsMigrationApplied(migrationBaselineID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !applied </span><span class="cov8" title="1">{
                        if err := r.MarkMigrationApplied(migrationBaselineID, migrationBaselineName); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        // If identity columns exist, mark identity migration applied
        <span class="cov8" title="1">if columnExists(r.db, "archives", "uid") &amp;&amp; columnExists(r.db, "archives", "managed") &amp;&amp; columnExists(r.db, "archives", "status") &amp;&amp; columnExists(r.db, "archives", "last_seen") </span><span class="cov8" title="1">{
                applied, err := r.IsMigrationApplied(migrationIdentityID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !applied </span><span class="cov8" title="1">{
                        if err := r.MarkMigrationApplied(migrationIdentityID, migrationIdentityName); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

const (
        migrationTrashID   = "0003_trash_fields"
        migrationTrashName = "Add deleted_at and original_path for trash support"
)

// ApplyPendingMigrations runs known migrations that haven't been marked applied yet
func (r *Registry) ApplyPendingMigrations() error <span class="cov8" title="1">{
        if err := r.EnsureMigrationsTable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // 0001 &amp; 0002 are effectively applied via initSchema + RecordCurrentSchemaAsApplied
        // 0003: trash support
        <span class="cov8" title="1">applied, err := r.IsMigrationApplied(migrationTrashID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !applied </span><span class="cov8" title="1">{
                tx, err := r.db.Begin()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Add columns if missing
                <span class="cov8" title="1">if !columnExists(r.db, "archives", "deleted_at") </span><span class="cov0" title="0">{
                        if _, err := tx.Exec(`ALTER TABLE archives ADD COLUMN deleted_at TIMESTAMP`); err != nil </span><span class="cov0" title="0">{
                                _ = tx.Rollback() // best-effort rollback
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if !columnExists(r.db, "archives", "original_path") </span><span class="cov0" title="0">{
                        if _, err := tx.Exec(`ALTER TABLE archives ADD COLUMN original_path TEXT`); err != nil </span><span class="cov0" title="0">{
                                _ = tx.Rollback() // best-effort rollback
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := r.MarkMigrationApplied(migrationTrashID, migrationTrashName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func tableExists(db *sql.DB, table string) bool <span class="cov8" title="1">{
        row := db.QueryRow(`SELECT name FROM sqlite_master WHERE type='table' AND name=?`, table)
        var name string
        if err := row.Scan(&amp;name); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return name == table</span>
}

func columnExists(db *sql.DB, table, column string) bool <span class="cov8" title="1">{
        rows, err := db.Query(fmt.Sprintf(`PRAGMA table_info(%s)`, table))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var cid int
                var name, ctype string
                var notnull, pk int
                var dflt sql.NullString
                if err := rows.Scan(&amp;cid, &amp;name, &amp;ctype, &amp;notnull, &amp;dflt, &amp;pk); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if name == column </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package storage

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

// Registry manages the SQLite database for archive metadata
type Registry struct {
        db     *sql.DB
        dbPath string
}

// NewRegistry creates a new registry instance
func NewRegistry(dbPath string) (*Registry, error) <span class="cov8" title="1">{
        // Ensure the directory exists
        dir := filepath.Dir(dbPath)
        // #nosec G301: create registry directory with restricted permissions
        if err := os.MkdirAll(dir, 0750); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create registry directory: %w", err)
        }</span>

        // Open the database
        <span class="cov8" title="1">db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set file permissions
        <span class="cov8" title="1">if err := os.Chmod(dbPath, 0600); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                _ = db.Close() // best-effort close on error
                return nil, fmt.Errorf("failed to set database permissions: %w", err)
        }</span>

        <span class="cov8" title="1">r := &amp;Registry{db: db, dbPath: dbPath}

        // Initialize the schema
        if err := r.initSchema(); err != nil </span><span class="cov8" title="1">{
                _ = db.Close() // best-effort close on error
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// initSchema creates the database tables if they don't exist and applies migrations
func (r *Registry) initSchema() error <span class="cov8" title="1">{
        // Create full modern schema for new installations
        query := `
        CREATE TABLE IF NOT EXISTS archives (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                uid TEXT UNIQUE,
                name TEXT UNIQUE NOT NULL,
                path TEXT NOT NULL,
                size INTEGER NOT NULL,
                created TIMESTAMP NOT NULL,
                checksum TEXT,
                profile TEXT,
                managed BOOLEAN DEFAULT FALSE,
                status TEXT NOT NULL DEFAULT 'present',
                last_seen TIMESTAMP,
                deleted_at TIMESTAMP,
                original_path TEXT,
                uploaded BOOLEAN DEFAULT FALSE,
                destination TEXT,
                uploaded_at TIMESTAMP,
                metadata TEXT
        );

        CREATE INDEX IF NOT EXISTS idx_archives_created ON archives(created);
        CREATE INDEX IF NOT EXISTS idx_archives_uploaded ON archives(uploaded);
        CREATE INDEX IF NOT EXISTS idx_archives_destination ON archives(destination);
        CREATE INDEX IF NOT EXISTS idx_archives_checksum ON archives(checksum);
        CREATE UNIQUE INDEX IF NOT EXISTS idx_archives_uid ON archives(uid);
        `

        if _, err := r.db.Exec(query); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Apply proper migration system
        <span class="cov8" title="1">if err := r.RecordCurrentSchemaAsApplied(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record schema state: %w", err)
        }</span>

        <span class="cov8" title="1">if err := r.ApplyPendingMigrations(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply migrations: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Add inserts a new archive into the registry
func (r *Registry) Add(archive *Archive) error <span class="cov8" title="1">{
        query := `
        INSERT INTO archives (uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                archive.UID,
                archive.Name,
                archive.Path,
                archive.Size,
                archive.Created,
                archive.Checksum,
                archive.Profile,
                archive.Managed,
                archive.Status,
                archive.LastSeen,
                archive.DeletedAt,
                archive.OriginalPath,
                archive.Uploaded,
                archive.Destination,
                archive.UploadedAt,
                archive.Metadata,
        )

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to add archive: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov8" title="1">archive.ID = id
        return nil</span>
}

// Get retrieves an archive by name
func (r *Registry) Get(name string) (*Archive, error) <span class="cov8" title="1">{
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE name = ?
        `

        archive := &amp;Archive{}
        err := r.db.QueryRow(query, name).Scan(
                &amp;archive.ID,
                &amp;archive.UID,
                &amp;archive.Name,
                &amp;archive.Path,
                &amp;archive.Size,
                &amp;archive.Created,
                &amp;archive.Checksum,
                &amp;archive.Profile,
                &amp;archive.Managed,
                &amp;archive.Status,
                &amp;archive.LastSeen,
                &amp;archive.DeletedAt,
                &amp;archive.OriginalPath,
                &amp;archive.Uploaded,
                &amp;archive.Destination,
                &amp;archive.UploadedAt,
                &amp;archive.Metadata,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("archive not found: %s", name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get archive: %w", err)
        }</span>

        <span class="cov8" title="1">return archive, nil</span>
}

// Exists reports whether an archive with the given name exists.
// Returns (true, nil) when found; (false, nil) when not found; (false, err) on other errors.
func (r *Registry) Exists(name string) (bool, error) <span class="cov0" title="0">{
        _, err := r.Get(name)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: differentiate not-found via sentinel; for now, treat any error as not found
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// List returns all archives
func (r *Registry) List() ([]*Archive, error) <span class="cov8" title="1">{
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        ORDER BY created DESC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list archives: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var archives []*Archive
        for rows.Next() </span><span class="cov8" title="1">{
                archive := &amp;Archive{}
                err := rows.Scan(
                        &amp;archive.ID,
                        &amp;archive.UID,
                        &amp;archive.Name,
                        &amp;archive.Path,
                        &amp;archive.Size,
                        &amp;archive.Created,
                        &amp;archive.Checksum,
                        &amp;archive.Profile,
                        &amp;archive.Managed,
                        &amp;archive.Status,
                        &amp;archive.LastSeen,
                        &amp;archive.DeletedAt,
                        &amp;archive.OriginalPath,
                        &amp;archive.Uploaded,
                        &amp;archive.Destination,
                        &amp;archive.UploadedAt,
                        &amp;archive.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan archive: %w", err)
                }</span>
                <span class="cov8" title="1">archives = append(archives, archive)</span>
        }

        <span class="cov8" title="1">return archives, rows.Err()</span>
}

// ListNotUploaded returns archives that haven't been uploaded
func (r *Registry) ListNotUploaded() ([]*Archive, error) <span class="cov8" title="1">{
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE uploaded = FALSE
        ORDER BY created DESC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list not uploaded archives: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var archives []*Archive
        for rows.Next() </span><span class="cov8" title="1">{
                archive := &amp;Archive{}
                err := rows.Scan(
                        &amp;archive.ID,
                        &amp;archive.UID,
                        &amp;archive.Name,
                        &amp;archive.Path,
                        &amp;archive.Size,
                        &amp;archive.Created,
                        &amp;archive.Checksum,
                        &amp;archive.Profile,
                        &amp;archive.Managed,
                        &amp;archive.Status,
                        &amp;archive.LastSeen,
                        &amp;archive.DeletedAt,
                        &amp;archive.OriginalPath,
                        &amp;archive.Uploaded,
                        &amp;archive.Destination,
                        &amp;archive.UploadedAt,
                        &amp;archive.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan archive: %w", err)
                }</span>
                <span class="cov8" title="1">archives = append(archives, archive)</span>
        }

        <span class="cov8" title="1">return archives, rows.Err()</span>
}

// ListOlderThan returns archives older than the specified duration
func (r *Registry) ListOlderThan(duration time.Duration) ([]*Archive, error) <span class="cov8" title="1">{
        cutoff := time.Now().Add(-duration)
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE created &lt; ?
        ORDER BY created DESC
        `

        rows, err := r.db.Query(query, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list older archives: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var archives []*Archive
        for rows.Next() </span><span class="cov8" title="1">{
                archive := &amp;Archive{}
                err := rows.Scan(
                        &amp;archive.ID,
                        &amp;archive.UID,
                        &amp;archive.Name,
                        &amp;archive.Path,
                        &amp;archive.Size,
                        &amp;archive.Created,
                        &amp;archive.Checksum,
                        &amp;archive.Profile,
                        &amp;archive.Managed,
                        &amp;archive.Status,
                        &amp;archive.LastSeen,
                        &amp;archive.DeletedAt,
                        &amp;archive.OriginalPath,
                        &amp;archive.Uploaded,
                        &amp;archive.Destination,
                        &amp;archive.UploadedAt,
                        &amp;archive.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan archive: %w", err)
                }</span>
                <span class="cov8" title="1">archives = append(archives, archive)</span>
        }

        <span class="cov8" title="1">return archives, rows.Err()</span>
}

// Update updates an existing archive
func (r *Registry) Update(archive *Archive) error <span class="cov8" title="1">{
        query := `
        UPDATE archives
        SET uid = ?, path = ?, size = ?, checksum = ?, profile = ?, managed = ?, status = ?, last_seen = ?, deleted_at = ?, original_path = ?, uploaded = ?, destination = ?, uploaded_at = ?, metadata = ?
        WHERE id = ?
        `

        _, err := r.db.Exec(query,
                archive.UID,
                archive.Path,
                archive.Size,
                archive.Checksum,
                archive.Profile,
                archive.Managed,
                archive.Status,
                archive.LastSeen,
                archive.DeletedAt,
                archive.OriginalPath,
                archive.Uploaded,
                archive.Destination,
                archive.UploadedAt,
                archive.Metadata,
                archive.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update archive: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BackfillUIDs sets a UID for rows missing it
func (r *Registry) BackfillUIDs(gen func() string) error <span class="cov8" title="1">{
        rows, err := r.db.Query(`SELECT id FROM archives WHERE uid IS NULL OR uid = ''`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var ids []int64
        for rows.Next() </span><span class="cov8" title="1">{
                var id int64
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ids = append(ids, id)</span>
        }
        <span class="cov8" title="1">for _, id := range ids </span><span class="cov8" title="1">{
                if _, err := r.db.Exec(`UPDATE archives SET uid = ? WHERE id = ?`, gen(), id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetByID retrieves an archive by numeric id
func (r *Registry) GetByID(id int64) (*Archive, error) <span class="cov0" title="0">{
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE id = ?`
        archive := &amp;Archive{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;archive.ID,
                &amp;archive.UID,
                &amp;archive.Name,
                &amp;archive.Path,
                &amp;archive.Size,
                &amp;archive.Created,
                &amp;archive.Checksum,
                &amp;archive.Profile,
                &amp;archive.Managed,
                &amp;archive.Status,
                &amp;archive.LastSeen,
                &amp;archive.DeletedAt,
                &amp;archive.OriginalPath,
                &amp;archive.Uploaded,
                &amp;archive.Destination,
                &amp;archive.UploadedAt,
                &amp;archive.Metadata,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("archive not found: %d", id)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get archive by id: %w", err)
        }</span>
        <span class="cov0" title="0">return archive, nil</span>
}

// GetByUID retrieves an archive by exact UID
func (r *Registry) GetByUID(uid string) (*Archive, error) <span class="cov8" title="1">{
        query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE uid = ?`
        archive := &amp;Archive{}
        err := r.db.QueryRow(query, uid).Scan(
                &amp;archive.ID,
                &amp;archive.UID,
                &amp;archive.Name,
                &amp;archive.Path,
                &amp;archive.Size,
                &amp;archive.Created,
                &amp;archive.Checksum,
                &amp;archive.Profile,
                &amp;archive.Managed,
                &amp;archive.Status,
                &amp;archive.LastSeen,
                &amp;archive.DeletedAt,
                &amp;archive.OriginalPath,
                &amp;archive.Uploaded,
                &amp;archive.Destination,
                &amp;archive.UploadedAt,
                &amp;archive.Metadata,
        )
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("archive not found: %s", uid)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get archive by uid: %w", err)
        }</span>
        <span class="cov8" title="1">return archive, nil</span>
}

// FindByUIDPrefix returns archives whose UID starts with prefix
func (r *Registry) FindByUIDPrefix(prefix string, limit int) ([]*Archive, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov8" title="1">query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE uid LIKE ?
        ORDER BY created DESC
        LIMIT ?`
        rows, err := r.db.Query(query, prefix+"%", limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query by uid prefix: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var out []*Archive
        for rows.Next() </span><span class="cov8" title="1">{
                archive := &amp;Archive{}
                if err := rows.Scan(
                        &amp;archive.ID,
                        &amp;archive.UID,
                        &amp;archive.Name,
                        &amp;archive.Path,
                        &amp;archive.Size,
                        &amp;archive.Created,
                        &amp;archive.Checksum,
                        &amp;archive.Profile,
                        &amp;archive.Managed,
                        &amp;archive.Status,
                        &amp;archive.LastSeen,
                        &amp;archive.DeletedAt,
                        &amp;archive.OriginalPath,
                        &amp;archive.Uploaded,
                        &amp;archive.Destination,
                        &amp;archive.UploadedAt,
                        &amp;archive.Metadata,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out = append(out, archive)</span>
        }
        <span class="cov8" title="1">return out, rows.Err()</span>
}

// FindByChecksumPrefix returns archives whose checksum starts with prefix
func (r *Registry) FindByChecksumPrefix(prefix string, limit int) ([]*Archive, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov8" title="1">query := `
        SELECT id, uid, name, path, size, created, checksum, profile, managed, status, last_seen, deleted_at, original_path, uploaded, destination, uploaded_at, metadata
        FROM archives
        WHERE checksum LIKE ?
        ORDER BY created DESC
        LIMIT ?`
        rows, err := r.db.Query(query, prefix+"%", limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query by checksum prefix: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var out []*Archive
        for rows.Next() </span><span class="cov8" title="1">{
                archive := &amp;Archive{}
                if err := rows.Scan(
                        &amp;archive.ID,
                        &amp;archive.UID,
                        &amp;archive.Name,
                        &amp;archive.Path,
                        &amp;archive.Size,
                        &amp;archive.Created,
                        &amp;archive.Checksum,
                        &amp;archive.Profile,
                        &amp;archive.Managed,
                        &amp;archive.Status,
                        &amp;archive.LastSeen,
                        &amp;archive.DeletedAt,
                        &amp;archive.OriginalPath,
                        &amp;archive.Uploaded,
                        &amp;archive.Destination,
                        &amp;archive.UploadedAt,
                        &amp;archive.Metadata,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out = append(out, archive)</span>
        }
        <span class="cov8" title="1">return out, rows.Err()</span>
}

// Delete removes an archive from the registry
func (r *Registry) Delete(name string) error <span class="cov8" title="1">{
        query := `DELETE FROM archives WHERE name = ?`
        _, err := r.db.Exec(query, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete archive: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Path returns the underlying database file path (for backups)
func (r *Registry) Path() string <span class="cov0" title="0">{ return r.dbPath }</span>

// Close closes the database connection
func (r *Registry) Close() error <span class="cov8" title="1">{
        return r.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package storage

import (
        "strconv"
        "strings"
)

// Error types defined in errors.go

// Resolver resolves user input into a single registry archive
// Resolution order: numeric ID -&gt; exact UID -&gt; UID prefix -&gt; checksum prefix -&gt; exact name
// Default minimum prefix length is 4 to avoid accidental broad matches.

type Resolver struct {
        reg             *Registry
        MinPrefixLength int
        MaxCandidates   int
}

func NewResolver(reg *Registry) *Resolver <span class="cov8" title="1">{
        // Default min ULID prefix length: 12 (covers full timestamp + 2 chars randomness)
        return &amp;Resolver{reg: reg, MinPrefixLength: 12, MaxCandidates: 50}
}</span>

func (r *Resolver) Resolve(input string) (*Archive, error) <span class="cov8" title="1">{
        trim := strings.TrimSpace(input)
        if trim == "" </span><span class="cov0" title="0">{
                return nil, &amp;ArchiveNotFoundError{ID: input}
        }</span>

        // 1) Numeric ID
        <span class="cov8" title="1">if isAllDigits(trim) </span><span class="cov0" title="0">{
                if id, err := strconv.ParseInt(trim, 10, 64); err == nil </span><span class="cov0" title="0">{
                        if a, err := r.reg.GetByID(id); err == nil </span><span class="cov0" title="0">{
                                return a, nil
                        }</span>
                }
        }

        // 2) Exact UID
        <span class="cov8" title="1">if a, err := r.reg.GetByUID(trim); err == nil </span><span class="cov8" title="1">{
                return a, nil
        }</span>

        // 3) UID prefix (min length)
        <span class="cov8" title="1">if len(trim) &gt;= r.MinPrefixLength </span><span class="cov8" title="1">{
                if matches, err := r.reg.FindByUIDPrefix(trim, r.MaxCandidates); err == nil </span><span class="cov8" title="1">{
                        switch len(matches) </span>{
                        case 0:<span class="cov8" title="1"></span>
                                // continue
                        case 1:<span class="cov8" title="1">
                                return matches[0], nil</span>
                        default:<span class="cov8" title="1">
                                return nil, &amp;AmbiguousIDError{ID: input, Matches: matches}</span>
                        }
                }
        }

        // 4) Checksum prefix (min length)
        <span class="cov8" title="1">if len(trim) &gt;= r.MinPrefixLength </span><span class="cov8" title="1">{
                if matches, err := r.reg.FindByChecksumPrefix(trim, r.MaxCandidates); err == nil </span><span class="cov8" title="1">{
                        switch len(matches) </span>{
                        case 0:<span class="cov8" title="1"></span>
                                // continue
                        case 1:<span class="cov8" title="1">
                                return matches[0], nil</span>
                        default:<span class="cov0" title="0">
                                return nil, &amp;AmbiguousIDError{ID: input, Matches: matches}</span>
                        }
                }
        }

        // 5) Exact name
        <span class="cov8" title="1">if a, err := r.reg.Get(trim); err == nil </span><span class="cov8" title="1">{
                return a, nil
        }</span>

        <span class="cov8" title="1">return nil, &amp;ArchiveNotFoundError{ID: input}</span>
}

func isAllDigits(s string) bool <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, ch := range s </span><span class="cov8" title="1">{
                if ch &lt; '0' || ch &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package storage

import (
        "fmt"
        "os"
        "path/filepath"
        "testing"
        "time"
)

// Test helpers for MAS operations per 7EP-0004

// TestRegistry creates an in-memory registry for testing
func TestRegistry(t *testing.T) *Registry <span class="cov0" title="0">{
        t.Helper()

        // Create temp directory for test database
        tmpDir := t.TempDir()
        dbPath := filepath.Join(tmpDir, "test.db")

        reg, err := NewRegistry(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test registry: %v", err)
        }</span>

        // Initialize schema
        <span class="cov0" title="0">if err := reg.initSchema(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to init schema: %v", err)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = reg.Close()          // best-effort close in test cleanup
                _ = os.RemoveAll(tmpDir) // best-effort cleanup in tests
        }</span>)

        <span class="cov0" title="0">return reg</span>
}

// CreateTestArchive creates a test archive with predictable data
func CreateTestArchive(t *testing.T, reg *Registry, name string, opts ...TestArchiveOption) *Archive <span class="cov0" title="0">{
        t.Helper()

        cfg := &amp;testArchiveConfig{
                name:    name,
                size:    1024,
                profile: "balanced",
                managed: true,
                status:  "present",
                created: time.Now(),
        }

        // Apply options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        // Generate ULID
        <span class="cov0" title="0">uid := generateUID()

        // Create archive
        archive := &amp;Archive{
                UID:      uid,
                Name:     cfg.name,
                Path:     filepath.Join("/test/archives", cfg.name),
                Size:     cfg.size,
                Created:  cfg.created,
                Checksum: fmt.Sprintf("sha256:%x", []byte(cfg.name)),
                Profile:  cfg.profile,
                Managed:  cfg.managed,
                Status:   cfg.status,
        }

        // Add archive
        if err := reg.Add(archive); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to add test archive: %v", err)
        }</span>

        <span class="cov0" title="0">return archive</span>
}

// TestArchiveOption configures test archive creation
type TestArchiveOption func(*testArchiveConfig)

type testArchiveConfig struct {
        name    string
        size    int64
        profile string
        managed bool
        status  string
        created time.Time
}

// WithSize sets archive size
func WithSize(size int64) TestArchiveOption <span class="cov0" title="0">{
        return func(cfg *testArchiveConfig) </span><span class="cov0" title="0">{
                cfg.size = size
        }</span>
}

// WithProfile sets compression profile
func WithProfile(profile string) TestArchiveOption <span class="cov0" title="0">{
        return func(cfg *testArchiveConfig) </span><span class="cov0" title="0">{
                cfg.profile = profile
        }</span>
}

// WithManaged sets managed status
func WithManaged(managed bool) TestArchiveOption <span class="cov0" title="0">{
        return func(cfg *testArchiveConfig) </span><span class="cov0" title="0">{
                cfg.managed = managed
        }</span>
}

// WithStatus sets archive status
func WithStatus(status string) TestArchiveOption <span class="cov0" title="0">{
        return func(cfg *testArchiveConfig) </span><span class="cov0" title="0">{
                cfg.status = status
        }</span>
}

// WithCreated sets creation time
func WithCreated(created time.Time) TestArchiveOption <span class="cov0" title="0">{
        return func(cfg *testArchiveConfig) </span><span class="cov0" title="0">{
                cfg.created = created
        }</span>
}

// CreateTestSet creates a standard set of test archives
func CreateTestSet(t *testing.T, reg *Registry) []*Archive <span class="cov0" title="0">{
        t.Helper()

        archives := []*Archive{
                CreateTestArchive(t, reg, "project-backup.7z",
                        WithSize(2*1024*1024),
                        WithProfile("documents")),

                CreateTestArchive(t, reg, "project-docs.7z",
                        WithSize(512*1024),
                        WithProfile("documents")),

                CreateTestArchive(t, reg, "media-files.7z",
                        WithSize(100*1024*1024),
                        WithProfile("media"),
                        WithManaged(false)),

                CreateTestArchive(t, reg, "old-archive.7z",
                        WithCreated(time.Now().Add(-30*24*time.Hour)),
                        WithStatus("deleted")),

                CreateTestArchive(t, reg, "missing-file.7z",
                        WithStatus("missing")),
        }

        return archives
}</span>

// AssertResolves verifies that an ID resolves to expected archive
func AssertResolves(t *testing.T, resolver *Resolver, input string, expected *Archive) <span class="cov0" title="0">{
        t.Helper()

        result, err := resolver.Resolve(input)
        if err != nil </span><span class="cov0" title="0">{
                t.Errorf("Failed to resolve '%s': %v", input, err)
                return
        }</span>

        <span class="cov0" title="0">if result.UID != expected.UID </span><span class="cov0" title="0">{
                t.Errorf("Resolved wrong archive for '%s': got %s, want %s",
                        input, result.UID, expected.UID)
        }</span>
}

// AssertAmbiguous verifies that an ID is ambiguous
func AssertAmbiguous(t *testing.T, resolver *Resolver, input string, expectedCount int) <span class="cov0" title="0">{
        t.Helper()

        _, err := resolver.Resolve(input)
        if err == nil </span><span class="cov0" title="0">{
                t.Errorf("Expected ambiguous error for '%s', got success", input)
                return
        }</span>

        <span class="cov0" title="0">ambErr, ok := err.(*AmbiguousIDError)
        if !ok </span><span class="cov0" title="0">{
                t.Errorf("Expected AmbiguousIDError for '%s', got %T", input, err)
                return
        }</span>

        <span class="cov0" title="0">if len(ambErr.Matches) != expectedCount </span><span class="cov0" title="0">{
                t.Errorf("Wrong match count for '%s': got %d, want %d",
                        input, len(ambErr.Matches), expectedCount)
        }</span>
}

// AssertNotFound verifies that an ID is not found
func AssertNotFound(t *testing.T, resolver *Resolver, input string) <span class="cov0" title="0">{
        t.Helper()

        _, err := resolver.Resolve(input)
        if err == nil </span><span class="cov0" title="0">{
                t.Errorf("Expected not found error for '%s', got success", input)
                return
        }</span>

        <span class="cov0" title="0">_, ok := err.(*ArchiveNotFoundError)
        if !ok </span><span class="cov0" title="0">{
                t.Errorf("Expected ArchiveNotFoundError for '%s', got %T", input, err)
        }</span>
}

// BenchmarkResolver helps benchmark resolution performance
func BenchmarkResolver(b *testing.B, archiveCount int) <span class="cov0" title="0">{
        // Create registry with many archives
        reg := TestRegistry(&amp;testing.T{})
        resolver := NewResolver(reg)

        // Create test archives
        archives := make([]*Archive, archiveCount)
        for i := 0; i &lt; archiveCount; i++ </span><span class="cov0" title="0">{
                archives[i] = &amp;Archive{
                        UID:  fmt.Sprintf("01K2E%06d", i),
                        Name: fmt.Sprintf("archive-%d.7z", i),
                }
                _ = reg.Add(archives[i])
        }</span>

        // Benchmark resolution
        <span class="cov0" title="0">b.ResetTimer()
        for i := 0; i &lt; b.N; i++ </span><span class="cov0" title="0">{
                // Test various resolution types
                _, _ = resolver.Resolve(archives[i%archiveCount].UID[:8])
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package storage

import (
        "crypto/rand"
        "time"

        ulid "github.com/oklog/ulid/v2"
)

// generateUID creates a proper ULID string (26 chars, lexicographically sortable by time)
func generateUID() string <span class="cov8" title="1">{
        entropy := ulid.Monotonic(rand.Reader, 0)
        id := ulid.MustNew(ulid.Timestamp(time.Now()), entropy)
        return id.String()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/adamstac/7zarch-go/cmd"
        "github.com/spf13/cobra"
)

var (
        // Version information - set during build
        Version   = "0.1.0-dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "7zarch-go",
                Short: "An intelligent archive management tool",
                Long: `7zarch-go optimizes compression based on content type, 
creating, testing, and managing archives with smart defaults and TrueNAS integration (soon).

Features:
- Intelligent compression profiles for different file types
- Concurrent archive testing for 10x faster verification
- Configuration presets for common workflows
- Comprehensive mode with checksums and metadata
- Single binary distribution`,
                Version: fmt.Sprintf("%s (built %s, commit %s)", Version, BuildTime, GitCommit),
        }

        // Add commands
        rootCmd.AddCommand(cmd.CreateCmd())
        rootCmd.AddCommand(cmd.TestCmd())
        rootCmd.AddCommand(cmd.UploadCmd())
        rootCmd.AddCommand(cmd.ListCmd())
        rootCmd.AddCommand(cmd.ProfilesCmd())
        rootCmd.AddCommand(cmd.ConfigCmd())
        // MAS commands (as top-level commands for convenience)
        rootCmd.AddCommand(cmd.MasShowCmd())   // "show" command
        rootCmd.AddCommand(cmd.MasDbCmd())     // "db" command
        rootCmd.AddCommand(cmd.MasDeleteCmd()) // "delete" command
        rootCmd.AddCommand(cmd.MasMoveCmd())   // "move" command
        // Trash Management (7EP-0001)
        rootCmd.AddCommand(cmd.RestoreCmd())
        rootCmd.AddCommand(cmd.TrashCmd())

        // Execute
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package generators provides comprehensive test dataset generation for 7zarch-go
// Built on 7EP-0006's proven metadata-only approach for efficient testing
package generators

import (
        "fmt"
        "math/rand"
        "testing"
        "time"
)

// ScenarioSpec defines what kind of test scenario to generate
// Simplified from DatasetSpec based on 7EP-0006 learnings
type ScenarioSpec struct {
        Name        string
        Count       int                   // Number of archives
        ULIDPattern ULIDPattern           // How to generate ULIDs
        Profiles    []ProfileDistribution // Profile mix
        TimeSpread  time.Duration         // Spread creation times over period
        SizePattern SizePattern           // Size distribution
        EdgeCases   []EdgeCase            // Special scenarios to include
}

// ULIDPattern defines how to generate ULID patterns for testing
type ULIDPattern string

const (
        ULIDUnique     ULIDPattern = "unique"     // All unique (7EP-0006 scaling tests)
        ULIDSimilar    ULIDPattern = "similar"    // Controlled similarity (7EP-0006 disambiguation)
        ULIDCollisions ULIDPattern = "collisions" // Intentional prefix overlaps
)

// SizePattern defines file size distribution patterns
type SizePattern string

const (
        SizeUniform    SizePattern = "uniform"   // Even distribution
        SizeRealistic  SizePattern = "realistic" // Log-normal (most files small, few large)
        SizeLargeFiles SizePattern = "large"     // Focus on large file scenarios
)

// EdgeCase defines special scenarios to test
type EdgeCase string

const (
        UnicodeFilenames      EdgeCase = "unicode_filenames"
        EmojiFilenames        EdgeCase = "emoji_filenames"
        SpecialCharacters     EdgeCase = "special_characters"
        LongFilenames         EdgeCase = "long_filenames"
        MaxPathLength         EdgeCase = "max_path_length"
        MinMaxFileSizes       EdgeCase = "min_max_file_sizes"
        TimeBoundaries        EdgeCase = "time_boundaries"
        MixedManagedExternal  EdgeCase = "mixed_managed_external"
        TimeSequencing        EdgeCase = "time_sequencing"
        ManagedExternalMix    EdgeCase = "managed_external_mix"
        CrossProfileFiltering EdgeCase = "cross_profile_filtering"
)

// ProfileDistribution defines how to distribute archive profiles
type ProfileDistribution struct {
        Profile string
        Weight  float32 // 0.0-1.0
}

// Archive represents a test archive (simplified from storage.Archive)
type Archive struct {
        UID          string
        Name         string
        Path         string
        Size         int64
        Created      time.Time
        Profile      string
        Managed      bool
        Status       string
        Checksum     string
        Uploaded     bool
        UploadedAt   *time.Time
        DeletedAt    *time.Time
        OriginalPath string
}

// Generator creates reproducible test scenarios using 7EP-0006 patterns
type Generator struct {
        seed int64
        rng  *rand.Rand
}

// NewGenerator creates a new test data generator with fixed seed
func NewGenerator(seed int64) *Generator <span class="cov0" title="0">{
        return &amp;Generator{
                seed: seed,
                // Deterministic RNG for test data generation only (not security-sensitive).
                // #nosec G404 — needs determinism in tests
                rng: rand.New(rand.NewSource(seed)),
        }
}</span>

// GenerateScenario creates archives based on scenario spec
// Builds directly on 7EP-0006's successful generateTestArchives() pattern
func (g *Generator) GenerateScenario(tb testing.TB, spec ScenarioSpec) []*Archive <span class="cov0" title="0">{
        tb.Helper()

        archives := make([]*Archive, spec.Count)
        profiles := extractProfiles(spec.Profiles)
        sizes := generateSizeDistribution(spec.SizePattern)
        baseTime := time.Now().Add(-spec.TimeSpread)

        for i := 0; i &lt; spec.Count; i++ </span><span class="cov0" title="0">{
                archive := &amp;Archive{
                        UID:      g.generateUID(i, spec.ULIDPattern),
                        Name:     fmt.Sprintf("%s-%04d.7z", spec.Name, i),
                        Path:     fmt.Sprintf("/tmp/test-%s-%04d.7z", spec.Name, i),
                        Size:     selectSize(sizes, g.rng),
                        Created:  g.generateCreationTime(baseTime, spec.TimeSpread, i, spec.Count),
                        Profile:  selectProfile(profiles, g.rng),
                        Managed:  g.rng.Float32() &lt; 0.9, // 90% managed (7EP-0006 pattern)
                        Status:   "present",
                        Checksum: fmt.Sprintf("sha256:%064x", i),
                }

                // Apply edge case modifications
                g.applyEdgeCases(archive, spec.EdgeCases, i)

                archives[i] = archive
        }</span>

        <span class="cov0" title="0">return archives</span>
}

// generateUID creates a ULID based on the pattern
func (g *Generator) generateUID(i int, pattern ULIDPattern) string <span class="cov0" title="0">{
        switch pattern </span>{
        case ULIDUnique:<span class="cov0" title="0">
                // Each ULID is completely unique - for scaling tests
                return fmt.Sprintf("01K%02d%05d%012d%05d",
                        g.rng.Intn(26), i, g.rng.Int63n(999999999999), g.rng.Intn(99999))</span>

        case ULIDSimilar:<span class="cov0" title="0">
                // Controlled similarity for disambiguation testing (7EP-0006 pattern)
                if i &lt; 100 </span><span class="cov0" title="0">{
                        // Group by tens for first 100: 01K2E00, 01K2E01, 01K2E02, etc.
                        return fmt.Sprintf("01K2E%02d%012d%08d", i/10, i, i*17)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("01K2F%02d%012d%08d", (i-100)/100, i, i*23)</span>

        case ULIDCollisions:<span class="cov0" title="0">
                // Intentional prefix collisions for stress testing resolution
                prefixCount := min(i/10+1, 5) // Group into 5 prefix buckets max
                return fmt.Sprintf("01K2G%02d%012d%08d", prefixCount, i, g.rng.Intn(99999999))</span>

        default:<span class="cov0" title="0">
                return g.generateUID(i, ULIDUnique)</span> // Safe default
        }
}

// generateCreationTime creates a time within the specified spread
func (g *Generator) generateCreationTime(baseTime time.Time, spread time.Duration, index, total int) time.Time <span class="cov0" title="0">{
        if total &lt;= 1 </span><span class="cov0" title="0">{
                return baseTime
        }</span>
        // Distribute evenly across the time spread
        <span class="cov0" title="0">offset := time.Duration(float64(spread) * float64(index) / float64(total-1))
        return baseTime.Add(offset)</span>
}

// applyEdgeCases modifies archive based on edge case requirements
func (g *Generator) applyEdgeCases(archive *Archive, edgeCases []EdgeCase, index int) <span class="cov0" title="0">{
        for _, ec := range edgeCases </span><span class="cov0" title="0">{
                switch ec </span>{
                case UnicodeFilenames:<span class="cov0" title="0">
                        names := []string{"测试文件", "файл", "ファイル", "αρχείο", "파일"}
                        archive.Name = fmt.Sprintf("%s-%04d.7z", names[index%len(names)], index)</span>

                case EmojiFilenames:<span class="cov0" title="0">
                        emojis := []string{"🚀", "📝", "🎉", "🔥", "💾"}
                        archive.Name = fmt.Sprintf("%sproject-%04d.7z", emojis[index%len(emojis)], index)</span>

                case SpecialCharacters:<span class="cov0" title="0">
                        special := []string{"file with spaces", "file[brackets]", "file(parens)", "file@symbol", "file#hash"}
                        archive.Name = fmt.Sprintf("%s-%04d.7z", special[index%len(special)], index)</span>

                case LongFilenames:<span class="cov0" title="0">
                        // Create a 255-character filename
                        longName := fmt.Sprintf("%s", repeatString("a", 240))
                        archive.Name = fmt.Sprintf("%s-%04d.7z", longName, index)</span>

                case MaxPathLength:<span class="cov0" title="0">
                        // Create deep directory hierarchy
                        deepPath := ""
                        for j := 0; j &lt; 20; j++ </span><span class="cov0" title="0">{
                                deepPath += fmt.Sprintf("/level%02d", j)
                        }</span>
                        <span class="cov0" title="0">archive.Path = fmt.Sprintf("%s/archive-%04d.7z", deepPath, index)</span>

                case MinMaxFileSizes:<span class="cov0" title="0">
                        if index%3 == 0 </span><span class="cov0" title="0">{
                                archive.Size = 0 // Zero-byte file
                        }</span> else<span class="cov0" title="0"> if index%3 == 1 </span><span class="cov0" title="0">{
                                archive.Size = 10 * 1024 * 1024 * 1024 // 10GB file
                        }</span>

                case TimeBoundaries:<span class="cov0" title="0">
                        if index%3 == 0 </span><span class="cov0" title="0">{
                                archive.Created = time.Unix(0, 0) // Unix epoch
                        }</span> else<span class="cov0" title="0"> if index%3 == 1 </span><span class="cov0" title="0">{
                                archive.Created = time.Date(2100, 1, 1, 0, 0, 0, 0, time.UTC) // Far future
                        }</span>

                case MixedManagedExternal:<span class="cov0" title="0">
                        archive.Managed = index%2 == 0</span> // Alternate between managed and external

                case TimeSequencing:<span class="cov0" title="0">
                        // Already handled in creation time generation
                        continue</span>

                case ManagedExternalMix:<span class="cov0" title="0">
                        // 70% managed, 30% external
                        archive.Managed = g.rng.Float32() &lt; 0.7</span>

                case CrossProfileFiltering:<span class="cov0" title="0">
                        // Ensure diverse profile distribution
                        profiles := []string{"documents", "media", "balanced", "code", "data"}
                        archive.Profile = profiles[index%len(profiles)]</span>
                }
        }
}

// Helper functions

func extractProfiles(distributions []ProfileDistribution) []string <span class="cov0" title="0">{
        if len(distributions) == 0 </span><span class="cov0" title="0">{
                return []string{"balanced"}
        }</span>

        <span class="cov0" title="0">profiles := make([]string, 0)
        for _, dist := range distributions </span><span class="cov0" title="0">{
                // Add profile proportionally to its weight
                count := int(dist.Weight * 100)
                for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        profiles = append(profiles, dist.Profile)
                }</span>
        }
        <span class="cov0" title="0">return profiles</span>
}

func generateSizeDistribution(pattern SizePattern) []int64 <span class="cov0" title="0">{
        switch pattern </span>{
        case SizeUniform:<span class="cov0" title="0">
                return []int64{1024, 100 * 1024, 10 * 1024 * 1024}</span> // 1KB, 100KB, 10MB

        case SizeRealistic:<span class="cov0" title="0">
                // 70% small, 25% medium, 5% large (realistic distribution)
                sizes := make([]int64, 0, 100)
                for i := 0; i &lt; 70; i++ </span><span class="cov0" title="0">{
                        sizes = append(sizes, 1024+int64(i*100)) // 1-8KB
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; 25; i++ </span><span class="cov0" title="0">{
                        sizes = append(sizes, 100*1024+int64(i*10000)) // 100KB-350KB
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        sizes = append(sizes, 10*1024*1024+int64(i*1024*1024)) // 10MB-15MB
                }</span>
                <span class="cov0" title="0">return sizes</span>

        case SizeLargeFiles:<span class="cov0" title="0">
                return []int64{100 * 1024 * 1024, 500 * 1024 * 1024, 1024 * 1024 * 1024}</span> // 100MB, 500MB, 1GB

        default:<span class="cov0" title="0">
                return []int64{1024, 100 * 1024, 10 * 1024 * 1024}</span> // Safe default
        }
}

func selectSize(sizes []int64, rng *rand.Rand) int64 <span class="cov0" title="0">{
        if len(sizes) == 0 </span><span class="cov0" title="0">{
                return 1024 // Default 1KB
        }</span>
        <span class="cov0" title="0">return sizes[rng.Intn(len(sizes))]</span>
}

func selectProfile(profiles []string, rng *rand.Rand) string <span class="cov0" title="0">{
        if len(profiles) == 0 </span><span class="cov0" title="0">{
                return "balanced"
        }</span>
        <span class="cov0" title="0">return profiles[rng.Intn(len(profiles))]</span>
}

func repeatString(s string, count int) string <span class="cov0" title="0">{
        result := ""
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                result += s
        }</span>
        <span class="cov0" title="0">return result</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package generators

import (
        "fmt"
        "time"
)

// PredefinedScenarios contains all available test scenarios
var PredefinedScenarios = map[string]ScenarioSpec{
        // Performance Testing Scenarios
        "disambiguation-stress": {
                Name:        "disambiguation-stress",
                Count:       1000,
                ULIDPattern: ULIDSimilar, // Creates controlled similarity like 7EP-0006
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.7},
                        {Profile: "media", Weight: 0.2},
                        {Profile: "balanced", Weight: 0.1},
                },
                SizePattern: SizeUniform,
                TimeSpread:  30 * 24 * time.Hour, // 30 days
        },

        "scaling-validation": {
                Name:        "scaling-validation",
                Count:       10000,
                ULIDPattern: ULIDUnique, // Each unique for pure scaling test
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.4},
                        {Profile: "media", Weight: 0.3},
                        {Profile: "balanced", Weight: 0.3},
                },
                SizePattern: SizeRealistic,        // Most small, few large
                TimeSpread:  365 * 24 * time.Hour, // Full year spread
        },

        "resolution-stress": {
                Name:        "resolution-stress",
                Count:       5000,
                ULIDPattern: ULIDCollisions, // Intentional prefix collisions
                Profiles: []ProfileDistribution{
                        {Profile: "balanced", Weight: 1.0},
                },
                SizePattern: SizeUniform,
                TimeSpread:  90 * 24 * time.Hour, // 3 months
        },

        // Integration Testing Scenarios
        "create-list-show-delete": {
                Name:        "create-list-show-delete",
                Count:       50,
                ULIDPattern: ULIDUnique,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.5},
                        {Profile: "media", Weight: 0.3},
                        {Profile: "balanced", Weight: 0.2},
                },
                SizePattern: SizeRealistic,
                TimeSpread:  7 * 24 * time.Hour, // Week timeline
                EdgeCases:   []EdgeCase{MixedManagedExternal, TimeSequencing},
        },

        "mixed-storage-scenario": {
                Name:        "mixed-storage-scenario",
                Count:       100,
                ULIDPattern: ULIDSimilar,
                Profiles: []ProfileDistribution{
                        {Profile: "balanced", Weight: 1.0},
                },
                SizePattern: SizeUniform,
                TimeSpread:  30 * 24 * time.Hour,
                EdgeCases:   []EdgeCase{ManagedExternalMix, CrossProfileFiltering},
        },

        "time-series-archives": {
                Name:        "time-series-archives",
                Count:       365, // One per day for a year
                ULIDPattern: ULIDUnique,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.6},
                        {Profile: "media", Weight: 0.3},
                        {Profile: "data", Weight: 0.1},
                },
                SizePattern: SizeRealistic,
                TimeSpread:  365 * 24 * time.Hour,
                EdgeCases:   []EdgeCase{TimeSequencing},
        },

        // Edge Case Testing Scenarios
        "unicode-names": {
                Name:        "unicode-names",
                Count:       25,
                ULIDPattern: ULIDUnique,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 1.0},
                },
                SizePattern: SizeUniform,
                TimeSpread:  24 * time.Hour,
                EdgeCases: []EdgeCase{
                        UnicodeFilenames,
                        EmojiFilenames,
                        SpecialCharacters,
                        LongFilenames,
                },
        },

        "boundary-conditions": {
                Name:        "boundary-conditions",
                Count:       30,
                ULIDPattern: ULIDCollisions, // Stress test resolution
                Profiles: []ProfileDistribution{
                        {Profile: "balanced", Weight: 1.0},
                },
                SizePattern: SizeLargeFiles, // Large file edge cases
                TimeSpread:  24 * time.Hour,
                EdgeCases: []EdgeCase{
                        MaxPathLength,
                        MinMaxFileSizes,
                        TimeBoundaries,
                },
        },

        // Small test scenarios for unit tests
        "small-test": {
                Name:        "small-test",
                Count:       10,
                ULIDPattern: ULIDUnique,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 1.0},
                },
                SizePattern: SizeUniform,
                TimeSpread:  24 * time.Hour,
        },

        "medium-test": {
                Name:        "medium-test",
                Count:       100,
                ULIDPattern: ULIDSimilar,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.5},
                        {Profile: "media", Weight: 0.5},
                },
                SizePattern: SizeRealistic,
                TimeSpread:  7 * 24 * time.Hour,
        },

        "large-test": {
                Name:        "large-test",
                Count:       1000,
                ULIDPattern: ULIDUnique,
                Profiles: []ProfileDistribution{
                        {Profile: "documents", Weight: 0.4},
                        {Profile: "media", Weight: 0.3},
                        {Profile: "balanced", Weight: 0.3},
                },
                SizePattern: SizeRealistic,
                TimeSpread:  30 * 24 * time.Hour,
        },
}

// GetScenario retrieves a predefined scenario by name
func GetScenario(name string) (ScenarioSpec, error) <span class="cov0" title="0">{
        spec, exists := PredefinedScenarios[name]
        if !exists </span><span class="cov0" title="0">{
                return ScenarioSpec{}, fmt.Errorf("scenario %q not found", name)
        }</span>
        <span class="cov0" title="0">return spec, nil</span>
}

// ListScenarios returns all available scenario names
func ListScenarios() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(PredefinedScenarios))
        for name := range PredefinedScenarios </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// ScenarioCategories groups scenarios by their purpose
var ScenarioCategories = map[string][]string{
        "performance": {
                "disambiguation-stress",
                "scaling-validation",
                "resolution-stress",
        },
        "integration": {
                "create-list-show-delete",
                "mixed-storage-scenario",
                "time-series-archives",
        },
        "edge-cases": {
                "unicode-names",
                "boundary-conditions",
        },
        "unit-tests": {
                "small-test",
                "medium-test",
                "large-test",
        },
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package helpers provides test utilities that integrate the dataset system with storage
package helpers

import (
        "fmt"
        "path/filepath"
        "testing"

        "github.com/adamstac/7zarch-go/internal/storage"
        "github.com/adamstac/7zarch-go/test-datasets/generators"
)

// TestRegistryWithScenario creates a registry populated with a predefined scenario
// Builds directly on 7EP-0006's successful setupRegistryWithArchives pattern
func TestRegistryWithScenario(tb testing.TB, scenarioName string) (*storage.Registry, []*storage.Archive) <span class="cov0" title="0">{
        tb.Helper()

        // Create temporary registry
        tmpDir := tb.TempDir()
        dbPath := filepath.Join(tmpDir, "test.db")

        reg, err := storage.NewRegistry(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to create test registry: %v", err)
        }</span>

        <span class="cov0" title="0">tb.Cleanup(func() </span><span class="cov0" title="0">{
                if err := reg.Close(); err != nil </span><span class="cov0" title="0">{
                        tb.Errorf("Failed to close registry: %v", err)
                }</span>
        })

        // Get scenario specification
        <span class="cov0" title="0">spec, err := generators.GetScenario(scenarioName)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to get scenario %q: %v", scenarioName, err)
        }</span>

        // Generate archives using scenario system
        <span class="cov0" title="0">generator := generators.NewGenerator(42) // Fixed seed like 7EP-0006
        testArchives := generator.GenerateScenario(tb, spec)

        // Convert to storage archives and add to registry
        archives := make([]*storage.Archive, len(testArchives))
        for i, ta := range testArchives </span><span class="cov0" title="0">{
                archive := &amp;storage.Archive{
                        UID:          ta.UID,
                        Name:         ta.Name,
                        Path:         ta.Path,
                        Size:         ta.Size,
                        Created:      ta.Created,
                        Profile:      ta.Profile,
                        Managed:      ta.Managed,
                        Status:       ta.Status,
                        Checksum:     ta.Checksum,
                        Uploaded:     ta.Uploaded,
                        UploadedAt:   ta.UploadedAt,
                        DeletedAt:    ta.DeletedAt,
                        OriginalPath: ta.OriginalPath,
                }

                if err := reg.Add(archive); err != nil </span><span class="cov0" title="0">{
                        tb.Fatalf("Failed to add test archive %d: %v", i, err)
                }</span>
                <span class="cov0" title="0">archives[i] = archive</span>
        }

        <span class="cov0" title="0">return reg, archives</span>
}

// BenchmarkWithScenario runs a benchmark with a predefined scenario
func BenchmarkWithScenario(b *testing.B, scenarioName string,
        benchmarkFn func(*testing.B, *storage.Registry, []*storage.Archive)) <span class="cov0" title="0">{

        reg, archives := TestRegistryWithScenario(b, scenarioName)

        b.ResetTimer()
        benchmarkFn(b, reg, archives)
}</span>

// CreateTestRegistry creates a simple test registry with the specified number of archives
// Simplified version for basic tests
func CreateTestRegistry(tb testing.TB, count int) (*storage.Registry, []*storage.Archive) <span class="cov0" title="0">{
        tb.Helper()

        spec := generators.ScenarioSpec{
                Name:        "test",
                Count:       count,
                ULIDPattern: generators.ULIDUnique,
                Profiles: []generators.ProfileDistribution{
                        {Profile: "balanced", Weight: 1.0},
                },
                SizePattern: generators.SizeUniform,
        }

        tmpDir := tb.TempDir()
        dbPath := filepath.Join(tmpDir, "test.db")

        reg, err := storage.NewRegistry(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to create test registry: %v", err)
        }</span>

        <span class="cov0" title="0">tb.Cleanup(func() </span><span class="cov0" title="0">{
                if err := reg.Close(); err != nil </span><span class="cov0" title="0">{
                        tb.Errorf("Failed to close registry: %v", err)
                }</span>
        })

        <span class="cov0" title="0">generator := generators.NewGenerator(42)
        testArchives := generator.GenerateScenario(tb, spec)

        archives := make([]*storage.Archive, len(testArchives))
        for i, ta := range testArchives </span><span class="cov0" title="0">{
                archive := &amp;storage.Archive{
                        UID:      ta.UID,
                        Name:     ta.Name,
                        Path:     ta.Path,
                        Size:     ta.Size,
                        Created:  ta.Created,
                        Profile:  ta.Profile,
                        Managed:  ta.Managed,
                        Status:   ta.Status,
                        Checksum: ta.Checksum,
                }

                if err := reg.Add(archive); err != nil </span><span class="cov0" title="0">{
                        tb.Fatalf("Failed to add test archive: %v", err)
                }</span>
                <span class="cov0" title="0">archives[i] = archive</span>
        }

        <span class="cov0" title="0">return reg, archives</span>
}

// AssertArchiveCount verifies the expected number of archives in the registry
func AssertArchiveCount(tb testing.TB, reg *storage.Registry, expected int) <span class="cov0" title="0">{
        tb.Helper()

        archives, err := reg.List()
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to list archives: %v", err)
        }</span>

        <span class="cov0" title="0">if len(archives) != expected </span><span class="cov0" title="0">{
                tb.Errorf("Expected %d archives, got %d", expected, len(archives))
        }</span>
}

// AssertResolves verifies that a ULID prefix resolves to the expected archive
func AssertResolves(tb testing.TB, resolver *storage.Resolver, prefix string, expectedUID string) <span class="cov0" title="0">{
        tb.Helper()

        resolved, err := resolver.Resolve(prefix)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to resolve %q: %v", prefix, err)
        }</span>

        <span class="cov0" title="0">if resolved.UID != expectedUID </span><span class="cov0" title="0">{
                tb.Errorf("Expected resolution of %q to %q, got %q", prefix, expectedUID, resolved.UID)
        }</span>
}

// AssertAmbiguous verifies that a ULID prefix is ambiguous
func AssertAmbiguous(tb testing.TB, resolver *storage.Resolver, prefix string) <span class="cov0" title="0">{
        tb.Helper()

        _, err := resolver.Resolve(prefix)
        if err == nil </span><span class="cov0" title="0">{
                tb.Errorf("Expected ambiguous error for prefix %q, but resolution succeeded", prefix)
        }</span>

        // Check if it's actually an ambiguous error
        <span class="cov0" title="0">if err != nil &amp;&amp; err.Error() != fmt.Sprintf("ambiguous prefix %q", prefix) </span><span class="cov0" title="0">{
                tb.Errorf("Expected ambiguous error for prefix %q, got: %v", prefix, err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
